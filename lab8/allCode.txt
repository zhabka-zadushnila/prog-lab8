
// ./allCode.txt
// ./db_creation.sql




CREATE TABLE users (
    login VARCHAR(50) PRIMARY KEY,
    salt VARCHAR(32) NOT NULL,
    password BYTEA   NOT NULL
);

CREATE TYPE dragon_color AS ENUM ('BLACK', 'YELLOW', 'ORANGE', 'BROWN');
CREATE TYPE dragon_type AS ENUM ('WATER', 'UNDERGROUND', 'AIR', 'FIRE');
CREATE TYPE dragon_character AS ENUM ('EVIL', 'CHAOTIC_EVIL', 'FICKLE');

CREATE TABLE dragons (
    id VARCHAR(255) PRIMARY KEY,
    name VARCHAR(255) NOT NULL CHECK (name <> ''),
    x DOUBLE PRECISION NOT NULL,
    y BIGINT NOT NULL CHECK (y <= 984),
    creation_date DATE NOT NULL DEFAULT CURRENT_DATE,
    age INTEGER NOT NULL CHECK (age > 0),
    color dragon_color NOT NULL,
    type dragon_type NOT NULL,
    character dragon_character,
    depth INTEGER,
    number_of_treasures DOUBLE PRECISION CHECK (number_of_treasures > 0),
    login VARCHAR(50) NOT NULL REFERENCES users(login),

    CHECK (
        (depth IS NULL AND number_of_treasures IS NULL) OR
        (depth IS NOT NULL AND number_of_treasures IS NOT NULL)
    )
);
// ./common/src/main/java/structs/wrappers/DragonDisplayWrapper.java
package structs.wrappers;


import structs.classes.Dragon;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.stream.Stream;

public class DragonDisplayWrapper implements Serializable {
    private final String key;
    private final Dragon originalDragon;
    private static final long serialVersionUID = 1L;

    public DragonDisplayWrapper(String key, Dragon dragon) {
        this.key = key;
        this.originalDragon = dragon;
    }

    public String getKey() {
        return key;
    }

    public String getOwner() {
        return originalDragon.getOwnerLogin();
    }

    public String getName() {
        return originalDragon.getName();
    }

    public double getX() {
        return originalDragon.getCoordinates().getX();
    }

    public long getY() {
        return originalDragon.getCoordinates().getY();
    }

    public LocalDate getCreationDate() {
        return originalDragon.getCreationDate();
    }

    public int getAge() {
        return originalDragon.getAge();
    }

    public String getColor() {
        return originalDragon.getColor().name();
    }

    public String getType() {
        return originalDragon.getType().name();
    }

    public String getCharacter() {
        return originalDragon.getCharacter() != null ? originalDragon.getCharacter().name() : "N/A";
    }

    public Integer getDepth() {
        return originalDragon.getCave() != null ? originalDragon.getCave().getDepth() : null;
    }

    public Double getTreasures() {
        return originalDragon.getCave() != null ? originalDragon.getCave().getNumberOfTreasures() : null;
    }

    public Dragon getOriginalDragon() {
        return originalDragon;
    }
    public Dragon getValue(){ return  originalDragon;}


    public Stream<String> getStreamOfFields() {
        return Stream.of(
                getKey(),
                getOwner(),
                getName(),
                String.valueOf(getX()),
                String.valueOf(getY()),
                getCreationDate().toString(),
                String.valueOf(getAge()),
                getColor(),
                getType(),
                getCharacter(),
                getDepth() != null ? String.valueOf(getDepth()) : "",
                getTreasures() != null ? String.valueOf(getTreasures()) : ""
        );
    }
}// ./common/src/main/java/structs/SQLAnswer.java
package structs;

import java.io.Serializable;
import java.sql.ResultSet;

public class SQLAnswer implements Serializable {
    private static final long serialVersionUID = 1L;
    boolean expectedBehabiour;
    String description;
    ResultSet output;
    boolean hasResults;

    public SQLAnswer(ResultSet output, String description, boolean expectedBehabiour) {
        this.output = output;
        this.description = description;
        this.expectedBehabiour = expectedBehabiour;
        if (output == null) {
            this.hasResults = false;
        } else {
            this.hasResults = true;
        }
    }

    public SQLAnswer(String description, boolean expectedBehabiour) {
        this(null, description, expectedBehabiour);
    }

    public String getDescription() {
        return description;
    }

    public ResultSet getOutput() {
        return output;
    }


    public boolean isExpectedBehabiour() {
        return expectedBehabiour;
    }

    public boolean HasResults() {
        return hasResults;
    }

}
// ./common/src/main/java/structs/User.java
package structs;

import java.io.Serializable;

public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    String login;
    String password;
    boolean registered;
    String context;

    public User(String login, String password) {
        this.login = login;
        this.password = password;
        if (login == null) {
            registered = false;
        } else {
            registered = true;
        }
    }

    public String getLogin() {
        return login;
    }

    public String getPassword() {
        return password;
    }

    public boolean isRegistered() {
        return registered;
    }
}
// ./common/src/main/java/structs/Packet.java
package structs;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Map;

import structs.classes.Dragon;
import structs.wrappers.DragonDisplayWrapper;


public class Packet implements Serializable {
    private static final long serialVersionUID = 1L;
    User user;
    PacketType packetType;
    String command;
    String[] arguments;
    Object object;
    String text;
    Map<String, Dragon> map;

    public Packet(PacketType packetType, String command, String[] arguments, User user) {
        this(packetType, command, arguments, null, user);
    }

    public Packet(PacketType packetType, String command, String[] arguments, Object object, User user) {
        this.packetType = packetType;
        this.command = command;
        this.arguments = arguments;
        this.object = object;
        this.user = user;
    }

    public Packet(PacketType packetType, String command, String[] arguments, Object object, String text, User user) {
        this.packetType = packetType;
        this.command = command;
        this.arguments = arguments;
        this.object = object;
        this.text = text;
        this.user = user;
    }

    public Packet(PacketType packetType, Map<String, Dragon> map){
        this.map = map;
        this.packetType = packetType;
    }

    public User getUser() {
        return user;
    }

    public Map<String, Dragon> getMap(){
        return map;
    }

    public AbstractMap.SimpleEntry<String, Object> getArgsObjectEntry() {
        try {
            return new AbstractMap.SimpleEntry<>(arguments[0], object);
        } catch (Exception e) {
            return null;
        }

    }

    public DragonDisplayWrapper getArgsObjectWrapper() {
        return (DragonDisplayWrapper) object;
    };

    public String getCommand() {
        return command;
    }

    public Object getArguments() {
        return arguments;
    }

    public String getText() {
        return text;
    }

    public boolean isText() {
        return packetType == PacketType.TEXT;
    }

    public boolean isCommand() {
        return packetType == PacketType.ARGS_COMMAND;
    }

    public boolean isObjectCommand() {
        return packetType == PacketType.OBJECT_COMMAND;
    }

    public boolean isMap(){
        return packetType == PacketType.MAP;
    }


    @Override
    public String toString() {
        if (packetType == PacketType.TEXT) {
            return text;
        }
        if (packetType == PacketType.ARGS_COMMAND || packetType == PacketType.OBJECT_COMMAND) {
            return command;
        }
        return "unknown";
    }
}
// ./common/src/main/java/structs/PacketType.java
package structs;

public enum PacketType {
    ARGS_COMMAND,
    OBJECT_COMMAND,
    TEXT,
    AUTH,
    MISC,
    MAP
}
// ./common/target/maven-status/maven-compiler-plugin/testCompile/default-testCompile/inputFiles.lst
// ./common/target/maven-status/maven-compiler-plugin/testCompile/default-testCompile/createdFiles.lst
// ./common/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/Packet.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/PacketType.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/SQLAnswer.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/User.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/Color.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/Coordinates.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/Dragon.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/DragonCave.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/DragonCharacter.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/DragonType.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/classes/Guarded.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/common/src/main/java/structs/wrappers/DragonDisplayWrapper.java
// ./common/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst
structs/classes/DragonCharacter.class
structs/PacketType.class
structs/Packet.class
structs/classes/Dragon.class
structs/classes/Guarded.class
structs/wrappers/DragonDisplayWrapper.class
structs/SQLAnswer.class
structs/User.class
structs/classes/Coordinates.class
structs/classes/DragonCave.class
structs/classes/DragonType.class
structs/classes/Color.class
// ./common/target/maven-archiver/pom.properties
artifactId=common
groupId=org.ITMO.s435169
version=v1
// ./common/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.ITMO.s435169</groupId>
        <artifactId>lab_8</artifactId>
        <version>v1</version>
    </parent>

    <artifactId>common</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>// ./server/src/main/java/utils/TypeComparator.java
package utils;

import java.util.Comparator;

import structs.classes.Dragon;

/**
 * Simple comparator that is used for default sort method in arrays.
 */
public class TypeComparator implements Comparator<Dragon> {
    @Override
    public int compare(Dragon d1, Dragon d2) {
        return d1.getType().compareTo(d2.getType());
    }
}
// ./server/src/main/java/utils/RequestConstructor.java
package utils;
import java.util.Map;
import java.util.logging.Logger;

import commands.BasicCommand;
import structs.Packet;
import structs.PacketType;
import structs.User;
import structs.classes.Dragon;

public class RequestConstructor {
    private static final Logger logger = Logger.getLogger(RequestConstructor.class.getName());

    public static Packet createRequest(BasicCommand command, String[] args, Object object, User user) {
        logger.fine("Created object request");
        if (object == null) {
            return new Packet(PacketType.ARGS_COMMAND, command.getName(), args, user);
        }
        return new Packet(PacketType.OBJECT_COMMAND, command.getName(), args, object, user);
    }

    public static Packet createRequest(String string) {
        logger.fine("Created text request with: " + string);
        return new Packet(PacketType.TEXT, null, null, null, string, null);
    }

    public static Packet createRequest(Map<String, Dragon> collection){
        return new Packet(PacketType.MAP, collection);
    }
}
// ./server/src/main/java/utils/RequestResponseTool.java
package utils;

import exceptions.WrongRequestException;
import structs.*;
import structs.wrappers.*;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.logging.Logger;

public class RequestResponseTool {
    private static final Logger logger = Logger.getLogger(RequestResponseTool.class.getName());

    static public boolean sendRequest(SocketChannel channel, Packet packet) {
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        try (ObjectOutputStream objectStream = new ObjectOutputStream(byteStream)) {
            objectStream.writeObject(packet);
            objectStream.flush();
            byte[] data = byteStream.toByteArray();
            logger.fine("Object written");

            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
            lengthBuffer.putInt(data.length);
            lengthBuffer.flip();
            channel.write(lengthBuffer);
            logger.fine("Packet size written");

            channel.write(ByteBuffer.wrap(data));
            logger.fine("Packet sent");
            return true;
        } catch (IOException e) {
            logger.warning("Произошла ошибка во время отправки запроса");
            e.printStackTrace();
            return false;
        }
    }

    static public Packet getRequest(SocketChannel channel) throws WrongRequestException {
        try {
            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
            while (lengthBuffer.hasRemaining()) {
                if (channel.read(lengthBuffer) == -1) {
                    return null;
                }
            }
            lengthBuffer.flip();
            int length = lengthBuffer.getInt();
            ByteBuffer buffer = ByteBuffer.allocate(length);
            logger.fine("Got request length");

            while (buffer.hasRemaining()) {
                if (channel.read(buffer) == -1) {
                    throw new EOFException("Unexpected end of stream");
                }
            }

            buffer.flip();
            logger.fine("Got request");
            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buffer.array());
            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);

            Object object = objectInputStream.readObject();
            logger.fine("Got request object");
            if (object instanceof Packet) {
                return (Packet) object;
            } else {
                System.out.println("damn thats bad packet" + object.toString());
                throw new WrongRequestException();
            }
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("Input/output error: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Received corrupted or unknown object: " + e.getMessage());
        }
        return null;
    }

}
// ./server/src/main/java/utils/InputChecker.java
package utils;

import exceptions.*;
import exceptions.RangeExceededException;

import java.math.BigDecimal;

/**
 * Class that is used just to check user's input
 */
public class InputChecker {
    /**
     * Checks if string is blank
     * @param input String
     * @return String if it is fine
     * @throws NullForbiddenException if String is not fine.
     */
    static public String inputNonNullChecker(String input) throws NullForbiddenException {
        if(input.trim().isBlank()){
            throw new NullForbiddenException();
        }
        else{
            return input;
        }
    }

    /**
     * MAGNUM OPUS <br>
     * MEME ITSELF <br>
     * PIECE OF ART (no)
     * @param input String
     * @param min min value (might be null for <em>-inf</em>)
     * @param max max value (might be null for <i>+inf</i>)
     * @param nonNull boolean parameter to check number for null
     * @param returnType Class which has to be returned
     * @return returns object of class according to returnType
     * @throws NullForbiddenException cause null is bad
     * @throws RangeExceededException cause getting out of limits is halal
     */
    static public <T extends Number> T inputRangeChecker(String input, Double min, Double max, boolean nonNull, Class<T> returnType) throws NullForbiddenException, RangeExceededException {
        if(nonNull){
            if(input.trim().isBlank()){throw new NullForbiddenException();}
        }

        if(input.trim().isBlank()){return null;}

        BigDecimal inputValue = new BigDecimal(input);

        if (min != null && inputValue.compareTo(new BigDecimal(min)) < 0) {
            throw new RangeExceededException(min, max);
        }

        if (max != null && inputValue.compareTo(new BigDecimal(max)) > 0) {
            throw new RangeExceededException(min, max);
        }

        if(returnType == Integer.class){
            return returnType.cast(inputValue.intValue());
        }
        if(returnType == Double.class){
            return returnType.cast(inputValue.doubleValue());
        }
        if(returnType == Float.class){
            return returnType.cast(inputValue.floatValue());
        }
        if(returnType == Long.class){
            return returnType.cast(inputValue.longValue());
        }
        return null;
    }

    /**
     * Method that is used to pick enum, works in any way
     * @param input String
     * @param enumClass Generic. Put here Enum that you want
     * @return returns enum if it was picked correctly
     */
    public static <E extends Enum<E>> E getEnum(String input, Class<E> enumClass) {
        try {
            return Enum.valueOf(enumClass, input.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new NoSuchElementException();
        }
    }
}
// ./server/src/main/java/commands/RemoveKeyCommand.java
package commands;

import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import structs.User;


/**
 * Removes element by key. That's all
 */
public class RemoveKeyCommand extends BasicCommand {
    public RemoveKeyCommand(CollectionManager collectionManager) {
        super("remove_key", "remove_key null : удалить элемент из коллекции по его ключу", collectionManager);
    }


    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException, NoSuchElementException {
        if (user == null) {
            return "bruh go register";
        }
        String[] args = (String[]) arguments;
        int deleted = 0;
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String masterId = args[0];

        if (!collectionManager.getDbManager().isDragonUsers(masterId, user.getLogin())) {
            return "you cannot change someones dragon";
        }

        if (collectionManager.getDbManager().deleteDragon(masterId, user.getLogin()).isExpectedBehabiour()) {
            if (collectionManager.hasElement(masterId)) {
                collectionManager.killElement(masterId);
                return ("Элемент " + masterId + " удалён успешно.");
            } else {
                throw new NoSuchElementException();
            }
        }
        return "misc troubles";
    }

}
// ./server/src/main/java/commands/RemoveGreaterKeyCommand.java
package commands;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import structs.User;
import structs.classes.Dragon;

/**
 * Removes elements with key greater than this one
 */
public class RemoveGreaterKeyCommand extends BasicCommand {
    public RemoveGreaterKeyCommand(CollectionManager collectionManager) {
        super("remove_greater_key", "remove_greater_key null : удалить из коллекции все элементы, ключ которых превышает заданный", collectionManager);
    }


    @Override
    public String execute(Object arguments, User user) {
        if (user == null) {
            return "bruh, register";
        }

        String[] args = (String[]) arguments;

        if (args.length == 0 || args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String masterId = args[0].trim();
        Map<String, Dragon> originalCollection = collectionManager.getCollection();
        Map<String, Dragon> newCollection = new HashMap<>(originalCollection);

        Set<String> keysToDelete = originalCollection.keySet().stream()
                .filter(key -> !key.equals(masterId))
                .filter(key -> masterId.compareTo(key) > 0)
                .filter(key -> collectionManager.getDbManager().isDragonUsers(key, user.getLogin()))
                .collect(Collectors.toSet());


        keysToDelete.forEach(newCollection::remove);
        int deleted = keysToDelete.size();
        if (collectionManager.getDbManager().deleteDragons(keysToDelete, user.getLogin()).isExpectedBehabiour()) {
            collectionManager.setCollection(newCollection);
        }
        return String.format("Deleted " + deleted + " objects ^_^");
    }
}
// ./server/src/main/java/commands/RemoveGreaterCommand.java
package commands;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import structs.User;
import structs.classes.Dragon;

/**
 * Removes greater elements (gets initial element by id)
 */
public class RemoveGreaterCommand extends BasicCommand {
    public RemoveGreaterCommand(CollectionManager collectionManager) {
        super("remove_greater", "remove_greater {element} : удалить из коллекции все элементы, превышающие заданный", collectionManager);
    }


    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException {
        if (user == null) {
            return "no you cant, log in to do it";
        }

        String[] args = (String[]) arguments;


        if (args.length == 0 || args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String input = args[0].trim();
        Dragon masterElement = collectionManager.getElement(input);

        if (masterElement == null) {
            return "Такого элемента нет";
        }

        Map<String, Dragon> originalCollection = collectionManager.getCollection();
        Map<String, Dragon> newCollection = new HashMap<>(originalCollection);

        Set<String> keysToDelete = originalCollection.entrySet().stream()
                .filter((entry) -> !masterElement.equals(entry.getValue()))
                .filter((entry) -> masterElement.compareTo(entry.getValue()) > 0)
                .filter((entry) -> collectionManager.getDbManager().isDragonUsers(entry.getKey(), user.getLogin()))
                .map(Map.Entry::getKey)
                .collect(Collectors.toSet());


        keysToDelete.forEach(newCollection::remove);
        int deleted = keysToDelete.size();
        
        if (collectionManager.getDbManager().deleteDragons(keysToDelete, user.getLogin()).isExpectedBehabiour()) {
            collectionManager.setCollection(newCollection);
        }
        return String.format("Deleted %d objects ^_^", deleted);
    }
}
// ./server/src/main/java/commands/ShowCommand.java
package commands;

import managers.CollectionManager;
import structs.User;

import java.util.stream.Collectors;

/**
 * Shows the collection
 */
public class ShowCommand extends BasicCommand {
    public ShowCommand(CollectionManager collectionManager) {
        super("show", "show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении", collectionManager);
    }


    @Override
    public String execute(Object args, User user) {
        return this.collectionManager.getCollection().entrySet().stream()
                .map((pair) -> ("Key (" + pair.getKey() + ")" + ":") + "\n" + ("\t" + pair.getValue().toString().replaceAll("\n", "\n\t") + "\n"))
                .collect(Collectors.joining());
    }
}
// ./server/src/main/java/commands/PrintFieldDescendingTypeCommand.java
package commands;

import java.util.stream.Collectors;

import managers.CollectionManager;
import structs.User;
import utils.TypeComparator;

/**
 * Outputs id : type
 */

public class PrintFieldDescendingTypeCommand extends BasicCommand {
    public PrintFieldDescendingTypeCommand(CollectionManager collectionManager) {
        super("print_field_descending_type", "print_field_descending_type : вывести значения поля type всех элементов в порядке убывания", collectionManager);
    }

    /**
     * Uses default List sort({@link TypeComparator})
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public String execute(Object args, User user) {
        return this.collectionManager.getCollection().values().stream()
                .sorted(new TypeComparator())
                .map((dragon) -> dragon.getType().toString() + "\n")
                .collect(Collectors.joining());
    }
}
// ./server/src/main/java/commands/RegisterCommand.java
package commands;

import managers.CommandManager;
import managers.DBManager;
import structs.SQLAnswer;
import structs.User;

public class RegisterCommand extends BasicCommand {
    CommandManager commandManager;
    DBManager dbManager;

    public RegisterCommand(CommandManager commandManager, DBManager dbManager) {
        super("register", "register: Буквально команда которая тебя зарегистрирует, лол");
        this.commandManager = commandManager;
        this.dbManager = dbManager;
    }

    @Override
    public String execute(Object arguments, User user) {
        if (user == null) {
            return "Something strange, seems like you've provided null";
        }
        SQLAnswer sqlAnswer = dbManager.registerUser(user.getLogin(), user.getPassword());
        if (sqlAnswer.isExpectedBehabiour()) {
            return "User registered successfully";
        }
        return sqlAnswer.getDescription();

    }
}
// ./server/src/main/java/commands/PrintAscendingCommand.java
package commands;

import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import managers.CollectionManager;
import structs.User;


/**
 * Outputs all the elements stored in its {@link CollectionManager} in ascending order
 */
public class PrintAscendingCommand extends BasicCommand {
    public PrintAscendingCommand(CollectionManager collectionManager) {
        super("print_ascending", "print_ascending : вывести элементы коллекции в порядке возрастания", collectionManager);
    }


    /**
     * Uses basic {@link List} sort(null) method.
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public String execute(Object args, User user) {
        return this.collectionManager.getCollection().entrySet().stream()
                .sorted(Comparator.comparing(Map.Entry::getValue))
                .map((entry) -> "Key (" + entry.getKey() + "):\n\t" + entry.getValue().toString().replaceAll("\n", "\n\t") + "\n")
                .collect(Collectors.joining());
    }
}
// ./server/src/main/java/commands/SaveCommand.java
package commands;


import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.FileManager;
import structs.User;

/**
 * Used to save something to file.
 */
public class SaveCommand extends BasicCommand {
    public SaveCommand(CollectionManager collectionManager) {
        super("save", "save : сохранить коллекцию в файл", collectionManager);
    }


    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException {
        String[] args = (String[]) arguments;

        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        FileManager.saveCollectionToFile(args[0], collectionManager.getCollection());
        return "saved";
    }


}
// ./server/src/main/java/commands/CountLessThanCharacterCommand.java
package commands;

import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import structs.User;
import structs.classes.DragonCharacter;
import utils.InputChecker;

/**
 * Outputs amount of elements in which character field contains value less than given
 */
public class CountLessThanCharacterCommand extends BasicCommand {
    public CountLessThanCharacterCommand(CollectionManager collectionManager) {
        super("count_less_than_character", "count_less_than_character character : вывести количество элементов, значение поля character которых меньше заданного", collectionManager);
    }


    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException, IllegalArgumentException {
        String[] args = (String[]) arguments;
        DragonCharacter character;
        if (args.length == 0 || args[0].trim().isBlank()) {
            return "You have to pick enum element: evil, chaotic_evil, fickle";
        }
        try {
            character = InputChecker.getEnum(args[0], DragonCharacter.class);
        } catch (NoSuchElementException e) {
            return "You have to pick enum element: evil, chaotic_evil, fickle";
        }
        return String.valueOf(collectionManager.getCollection().values().stream()
                .filter((dragon) -> dragon.getCharacter().compareTo(character) < 0)
                .count());
    }
}
// ./server/src/main/java/commands/ClearCommand.java
package commands;

import managers.CollectionManager;
import structs.User;

/**
 * Command to clear the collection.
 */
public class ClearCommand extends BasicCommand {
    public ClearCommand(CollectionManager collectionManager) {
        super("clear", "clear : очистить коллекцию", collectionManager);
    }

    /**
     * Basically executes {@link CollectionManager} method in its {@link CollectionManager}.
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public String execute(Object args, User user) {
        return "no you cant";
        //collectionManager.clearCollection();
        //return ("Collection was cleared successfully!");
    }

}
// ./server/src/main/java/commands/ReplaceIfLowerCommand.java
package commands;

import java.util.Map;

import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import structs.User;
import structs.classes.Dragon;
import structs.wrappers.DragonDisplayWrapper;


/**
 * Replaces all the elements that are lower
 */
public class ReplaceIfLowerCommand extends BasicCommand {
    CommandManager commandManager;

    public ReplaceIfLowerCommand(CollectionManager collectionManager, CommandManager commandManager) {
        super("replace_if_lowe", "replace_if_lowe null {element} : заменить значение по ключу, если новое значение меньше старого", collectionManager);
        this.commandManager = commandManager;
    }


    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException, NoSuchElementException {
        if (user == null) {
            return "register before it plz";
        }
        if (arguments == null) {
            return "Something strange, seems like you've provided null";
        }
        DragonDisplayWrapper entry = (DragonDisplayWrapper) arguments;
        Dragon dragon = entry.getValue();
        if (dragon == null) {
            return "";
        }


        if (collectionManager.hasElement(entry.getKey())) {

            if (collectionManager.getElement(entry.getKey()).compareTo(dragon) < 0) {
                if (collectionManager.getDbManager().updateDragon(dragon, entry.getKey(), user.getLogin()).isExpectedBehabiour()) {
                    collectionManager.replaceElement(entry.getKey(), dragon);
                    return "Successfully replaced an element";
                }
            } else {
                return ("New dragon is not less than new one, nothing has changed :)");
            }
        } else {
            throw new NoSuchElementException();
        }
        return "";
    }
}
// ./server/src/main/java/commands/UpdateCommand.java
package commands;

import java.util.Map;

import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import structs.User;
import structs.classes.Dragon;
import structs.wrappers.DragonDisplayWrapper;

/**
 * Used for updating element with specific id
 */
public class UpdateCommand extends BasicCommand {
    CommandManager commandManager;

    public UpdateCommand(CollectionManager collectionManager, CommandManager commandManager) {
        super("update", "update id {element} : обновить значение элемента коллекции, id которого равен заданному", collectionManager);
        this.commandManager = commandManager;
    }


    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException, NoSuchElementException {
        if (user == null) {
            return "please register to do such things";
        }

        DragonDisplayWrapper entry = (DragonDisplayWrapper) arguments;

        if (collectionManager.hasElement(entry.getKey())) {

            if (entry.getValue() == null) {
                return "Got null, nothing changes";
            }
            Dragon dragon = entry.getValue();
            if (!collectionManager.getDbManager().isDragonUsers(entry.getKey(), user.getLogin())) {
                return "you cannot change someones dragon";
            }
            if (collectionManager.getDbManager().updateDragon(dragon, entry.getKey(), user.getLogin()).isExpectedBehabiour()) {
                collectionManager.replaceElement(entry.getKey(), dragon);

                return "element " + entry.getKey() + " was replaced successfully";
            }
            return "some troubles with DB";
        } else {
            return new NoSuchElementException().toString();
        }
    }
}
// ./server/src/main/java/commands/InsertCommand.java
package commands;

import java.util.Map;

import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import structs.SQLAnswer;
import structs.User;
import structs.classes.Dragon;
import structs.wrappers.DragonDisplayWrapper;

/**
 * Command that is used for adding some stuff in collection. Operates with both {@link CommandManager} and {@link CollectionManager}.
 */

public class InsertCommand extends BasicCommand {
    CommandManager commandManager;

    public InsertCommand(CollectionManager collectionManager, CommandManager commandManager) {
        super("insert", "insert null {element} : добавить новый элемент с заданным ключом", collectionManager);
        this.commandManager = commandManager;
    }

    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException {
        if (user == null) {
            return "you are not registered yet";
        }

        if (arguments == null) {
            return "Something strange, seems like you've provided null";
        }

        DragonDisplayWrapper entry = (DragonDisplayWrapper) arguments;
        Dragon dragon = entry.getValue();
        if (entry.getValue() == null) {
            return "";
        }
        if (collectionManager.hasElement(entry.getKey())) {
            return "such element already exists, nothing changed";
        } else {
            SQLAnswer sqlAnswer = collectionManager.getDbManager().addDragon(entry.getKey(), dragon, user.getLogin());
            if (sqlAnswer.isExpectedBehabiour()) {
                collectionManager.addElement(entry.getKey(), entry.getValue());
            } else {
                return sqlAnswer.getDescription();
            }
        }

        return "element added";
    }


}
// ./server/src/main/java/commands/InfoCommand.java
package commands;

import managers.CollectionManager;
import structs.User;

import java.util.Map;

/**
 * Command, that briefly takes basic info from the {@link CollectionManager} and ouputs it into console.
 */

public class InfoCommand extends BasicCommand {

    public InfoCommand(CollectionManager collectionManager) {
        super("info", "info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)", collectionManager);
    }

    /**
     * Collects info from {@link CollectionManager} and outputs it.
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public String execute(Object args, User user) {
        Map<String, Object> map = collectionManager.getCollectionInfoMap();

        return ("Тип коллекции: " + map.get("Type").toString() + ".\n" +
                "Дата инициализации коллекции: " + map.get("Date").toString() + ".\n" +
                "Количество элементов в коллекции: " + map.get("ElementsQuantity").toString()
        );
    }
}
// ./server/src/main/java/commands/BasicCommand.java
package commands;

import exceptions.CustomException;
import managers.CollectionManager;
import structs.User;

import java.io.FileNotFoundException;

/**
 * Abstract class for all the commands. Contains exceptional name and description, execute() method.
 */

abstract public class BasicCommand {

    private final String name;
    private final String description;
    protected CollectionManager collectionManager;

    public BasicCommand(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public BasicCommand(String name, String description, CollectionManager collectionManager) {
        this(name, description);
        this.collectionManager = collectionManager;
    }


    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }


    /**
     * Execute function stands for basic command execution process. Execute method is being executed in CommandManager.
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    public String execute(Object args, User user) throws CustomException, FileNotFoundException {
        return (this.name + " is not done yet. ^_^");

    }
}
// ./server/src/main/java/commands/ExitCommand.java
package commands;

import structs.User;

/**
 * Some sort of wrapper for System.exit(0).
 */

public class ExitCommand extends BasicCommand {

    public ExitCommand() {
        super("exit", "exit : завершить программу (без сохранения в файл)");
    }

    /**
     * {@link System} check out an exit method
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public String execute(Object args, User user) {
        return "Nope";
    }
}// ./server/src/main/java/commands/LoginCommand.java
package commands;

import exceptions.NullArgsForbiddenException;
import managers.DBManager;
import structs.User;

public class LoginCommand extends BasicCommand {
    DBManager dbManager;

    public LoginCommand(DBManager dbManager) {
        super("login", "basically command to log u in");
        this.dbManager = dbManager;
    }

    @Override
    public String execute(Object arguments, User user) throws NullArgsForbiddenException {
        if (dbManager.checkUserExists(user.getLogin())) {
            if (dbManager.validateUser(user.getLogin(), user.getPassword())) {
                return "nice, u r in!";
            }
            return "wrong password";
        }
        return "no such user";
    }

}
// ./server/src/main/java/exceptions/CustomException.java
package exceptions;

import Interpreters.ServerCommandInterpreter;

/**
 * Class that is being caught by {@link ServerCommandInterpreter}, use it to create new exceptions for your commands
 */
public abstract class CustomException extends RuntimeException {
    public CustomException() {}

    /**
     * Any exception that is being caught during runtime will be displayed using toString().
     * @return String that explains main idea of exception
     */
    public String toString(){
        return "CustomException";
    }
}
// ./server/src/main/java/exceptions/WrongRequestException.java
package exceptions;

public class WrongRequestException extends CustomException {
    public WrongRequestException() {}

    @Override
    public String toString() {
        return "Seems like wrong request provided";
    }
}
// ./server/src/main/java/exceptions/NullArgsForbiddenException.java
package exceptions;

/**
 * Exception that is usually thrown by {@link utils.InputChecker}.
 */
public class NullArgsForbiddenException extends CustomException {
    @Override
    public String toString(){
        return "Null obtained when command needs input!";
    }
}
// ./server/src/main/java/exceptions/NullForbiddenException.java
package exceptions;

public class NullForbiddenException extends CustomException {
    public NullForbiddenException() {
    }

    @Override
    public String toString(){
        return "Null obtained in non-null field!";
    }

}
// ./server/src/main/java/exceptions/RangeExceededException.java
package exceptions;


/**
 * Exception that you can use to remind user to use specific range of numbers
 */
public class RangeExceededException extends CustomException {//checked/unchecked
    Double min;
    Double max;

    /**
     * You have to set borders in constructor of this exception. If you need only one-side restriction, put null for +-inf.
     * @param min Double (min num in range)
     * @param max Double (max num in range)
     */
    public RangeExceededException(Double min, Double max) {
        this.max = max;
        this.min = min;
    }

    @Override
    public String toString() {
        if(min == null){
            return "Expected range is less than " + max;
        }
        if(max == null){
            return "Expected range is bigger than " + min;
        }
        return "Expected range is a number between " + min + " and " + max;
    }
}
// ./server/src/main/java/exceptions/NoSuchColorException.java
package exceptions;

/**
 * Exception that is being thrown when user tries to pick color that does not exist
 */
public class NoSuchColorException extends CustomException {

  @Override
  public String toString(){
    return "Seems like there is no such color";
  }
}
// ./server/src/main/java/exceptions/EmptyRequestException.java
package exceptions;

public class EmptyRequestException extends CustomException {
    public EmptyRequestException() {}

    @Override
    public String toString(){
        return "Empty request was given.";
    }
}
// ./server/src/main/java/exceptions/NoSuchElementException.java
package exceptions;

/**
 * Exception that is being thrown when element was not found in collection
 */
public class NoSuchElementException extends CustomException {
    @Override
    public String toString(){
        return "No such element in collection";
    }
}
// ./server/src/main/java/exceptions/InfiniteFileRecursion.java
package exceptions;


/**
 * Exception that is used to notify user when recursion occurs
 */
public class InfiniteFileRecursion extends CustomException {
    @Override
    public String toString(){
        return "Seems like you are trying to create a file loop. Bruh, for what?";
    }
}
// ./server/src/main/java/handlers/ClientHandler.java
package handlers;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.logging.Logger;

import Interpreters.ServerCommandInterpreter;
import structs.Packet;
import structs.classes.Dragon;
import utils.RequestConstructor;
import utils.RequestResponseTool;

public class ClientHandler implements Runnable {
    private static final Logger logger = Logger.getLogger(ClientHandler.class.getName());

    private final SocketChannel socketChannel;
    private final ServerCommandInterpreter serverCommandInterpreter;
    private final ExecutorService processPool;
    private final ExecutorService writePool;

    public ClientHandler(SocketChannel socketChannel, ServerCommandInterpreter serverCommandInterpreter,
                         ExecutorService processPool, ExecutorService writePool) {
        this.socketChannel = socketChannel;
        this.serverCommandInterpreter = serverCommandInterpreter;
        this.processPool = processPool;
        this.writePool = writePool;
    }


    @Override
    public void run() {
        try {
            handleClient(socketChannel);
        } catch (IOException e) {
            logger.severe("Error handling client: " + e.getMessage());
        } finally {
            try {
                socketChannel.close();
            } catch (IOException e) {
                logger.fine("Failed to close socket: " + e.getMessage());
            }


        }
    }

    private void handleClient(SocketChannel socketChannel) throws IOException {
        socketChannel.configureBlocking(true);
        ByteBuffer buffer = ByteBuffer.allocate(1);
        int bytesRead = socketChannel.read(buffer);

        if (bytesRead == -1) {
            System.out.println("Client disconnected before sending message.");
            socketChannel.close();
            return;
        }

        if (bytesRead != 1) {
            System.out.println("Strange client hello accepted (" + String.valueOf(bytesRead) + " bytes)");
            logger.info("Strange client hello accepted");
            return;
        }
        buffer.flip();
        if (buffer.get() == 0x42) {
            buffer.clear();
            buffer.put((byte) 0x43);
            buffer.flip();
            socketChannel.write(buffer);
            socketChannel.configureBlocking(false);
            logger.info("New client registered");
        }
        while (socketChannel.isConnected()) {
            Packet packet = RequestResponseTool.getRequest(socketChannel);
            if (packet == null) {
                logger.info("Client disconnected before sending request");
                return;
            }

            processPool.execute(() -> processRequest(packet, socketChannel));
        }
    }

    private void processRequest(Packet packet, SocketChannel socketChannel) {
        try {
            if(packet.isMap()){
                writePool.execute(() -> sendResponse(socketChannel, serverCommandInterpreter.getCollectionManager().getCollection()));
            }else{
                String response = serverCommandInterpreter.executeRequest(packet);
                String result = (response != null) ? response : "Request executed successfully";
                writePool.execute(() -> sendResponse(socketChannel, result));
            }

            
        } catch (Exception e) {
            logger.severe("Error executing command: " + e.getMessage());
            writePool.execute(() -> sendResponse(socketChannel, "Internal server error"));
        }
    }

    private void sendResponse(SocketChannel socketChannel, String message) {
        System.out.println("Sending back: " + message);
        Packet responsePacket = RequestConstructor.createRequest(message);
        RequestResponseTool.sendRequest(socketChannel, responsePacket);
    }
    private void sendResponse(SocketChannel socketChannel, Map<String, Dragon> collection) {
        Packet responsePacket = RequestConstructor.createRequest(collection);
        RequestResponseTool.sendRequest(socketChannel, responsePacket);
    }
}// ./server/src/main/java/handlers/ProcessingHandler.java
package handlers;

import Interpreters.ServerCommandInterpreter;
import exceptions.CustomException;
import exceptions.EmptyRequestException;
import structs.Packet;
import structs.User;

import java.nio.channels.SocketChannel;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ProcessingHandler implements Runnable {
    private final String login;
    private final Packet packet;
    private final Map<String, User> userSessions;
    ServerCommandInterpreter serverCommandInterpreter;
    SocketChannel socketChannel;
    ExecutorService responseSender = Executors.newCachedThreadPool();

    public ProcessingHandler(SocketChannel socketChannel, String login, Packet packet, Map<String, User> userSessions, ServerCommandInterpreter serverCommandInterpreter) {
        this.login = login;
        this.packet = packet;
        this.userSessions = userSessions;
        this.socketChannel = socketChannel;
        this.serverCommandInterpreter = serverCommandInterpreter;
    }

    @Override
    public void run() {
        if (packet == null) {
            throw new EmptyRequestException();
        }
        
        try {
            if (packet.isCommand()) {

                responseSender.execute(new ResponseSender(socketChannel, serverCommandInterpreter.executeRequest(packet)));
            }
            if (packet.isObjectCommand()) {
                responseSender.execute(new ResponseSender(socketChannel, serverCommandInterpreter.executeRequest(packet)));
            }
        } catch (CustomException e) {
            System.out.println(e);
        }

    }
}
// ./server/src/main/java/handlers/ResponseSender.java
package handlers;

import managers.CommandManager;
import structs.Packet;
import utils.RequestConstructor;
import utils.RequestResponseTool;

import java.nio.channels.SocketChannel;

public class ResponseSender implements Runnable {
    private final String response;
    CommandManager commandManager;
    SocketChannel socketChannel;

    public ResponseSender(SocketChannel socketChannel, String response) {
        this.response = response;
        this.socketChannel = socketChannel;
    }


    @Override
    public void run() {
        Packet packet = RequestConstructor.createRequest(response);
        RequestResponseTool.sendRequest(socketChannel, packet);
    }
}
// ./server/src/main/java/handlers/ReadHandler.java
package handlers;

import Interpreters.ServerCommandInterpreter;
import exceptions.CustomException;
import structs.Packet;
import structs.User;
import utils.RequestResponseTool;

import java.io.IOException;
import java.nio.channels.SocketChannel;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.logging.Logger;

public class ReadHandler implements Runnable {
    private static final Logger logger = Logger.getLogger(ReadHandler.class.getName());
    private final SocketChannel socket;
    private final ExecutorService processingPool;
    private final Map<String, User> userSessions;
    private final ServerCommandInterpreter serverCommandInterpreter;

    public ReadHandler(SocketChannel socket, ExecutorService processingPool, Map<String, User> userSessions, ServerCommandInterpreter serverCommandInterpreter) {
        this.socket = socket;
        this.processingPool = processingPool;
        this.userSessions = userSessions;
        this.serverCommandInterpreter = serverCommandInterpreter;
    }

    @Override
    public void run() {
        Packet packet = RequestResponseTool.getRequest(socket);
        User user = packet.getUser();
        if (packet == null) {
            try {
                socket.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            logger.info("Client disconnected");
            return;
        }
        try {
            processingPool.execute(new ProcessingHandler(socket, user.getLogin(), packet, userSessions, serverCommandInterpreter));
        } catch (CustomException e) {
            e.printStackTrace();
        }
    }
}
// ./server/src/main/java/async/AsyncRequestSender.java
package async;

import java.util.concurrent.Callable;

public class AsyncRequestSender implements Callable {
    @Override
    public Object call() throws Exception {
        return null;
    }
}
// ./server/src/main/java/managers/CommandManager.java
package managers;

import Interpreters.ServerCommandInterpreter;
import commands.BasicCommand;

import java.util.HashMap;
import java.util.Map;

/**
 * Class that manages all the commands. Actually, that's some sort of a wrapper for Map ^_^
 * Maybe got no sense but still I love it and I think it is some sort of Controller in MVC.
 *
 *
*/
public class CommandManager {
    private final Map<String, BasicCommand> commandsMap = new HashMap<String, BasicCommand>();
    CollectionManager collectionManager;
    ServerCommandInterpreter serverCommandInterpreter;

    /**
     * Constructor for class
     * @param collectionManager basically a {@link CollectionManager}
     */
    public CommandManager(CollectionManager collectionManager) {
        this.collectionManager = collectionManager;
    }

    /**
     * Adds command in command manager.
     * @param command object of {@link BasicCommand} children
     */
    public void addCommand(BasicCommand command) {
        this.commandsMap.put(command.getName(), command);

    }

    public Map<String, BasicCommand> getCommandsMap() {
        return this.commandsMap;
    }

    public CollectionManager getCollectionManager(){
        return this.collectionManager;
    }

    public void setCommandInterpreter(ServerCommandInterpreter serverCommandInterpreter) {
        this.serverCommandInterpreter = serverCommandInterpreter;
    }

    public ServerCommandInterpreter getCommandInterpreter() {
        return serverCommandInterpreter;
    }


    public BasicCommand getCommand(String name){
        return commandsMap.get(name);
    }


}
// ./server/src/main/java/managers/DBManager.java
package managers;


import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.Base64;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import structs.SQLAnswer;
import structs.classes.Color;
import structs.classes.Coordinates;
import structs.classes.Dragon;
import structs.classes.DragonCave;
import structs.classes.DragonCharacter;
import structs.classes.DragonType;

public class DBManager {
    String sqlInsert = "INSERT INTO users (login, salt, password) VALUES (?, ?, ?)";
    String sqlRequest = "INSERT INTO dragons (id, name, x, y, creation_date, age, color, type, character, depth, number_of_treasures, login) " +
            "VALUES (?,?, ?, ?, ?, ?, ?::dragon_color, ?::dragon_type, ?::dragon_character, ?, ?, ?)";
    String sqlDragon = "SELECT 1 FROM dragons WHERE id = ? AND login = ?";
    private String url;
    private Connection connection; // bad (for threads) (множество connection'ов)

    public DBManager(String url, int port) {
        this.url = "jdbc:postgresql://" + url + ":" + port + "/studs";
        this.connection = null;
    }

    public SQLAnswer registerUser(String login, String password) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        if (checkUserExists(login)) {
            System.out.println("Someone tries to create an user that already exists");
            return new SQLAnswer("Such user already exists", false);
        }


        MessageDigest sha = null;
        try {
            sha = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            System.out.println(e.toString());
        }
        String salt = getRandomString();
        String pepper = "perpre ^_^";
        byte[] hashedPassword = new byte[0];
        try {
            hashedPassword = sha.digest((password + pepper + salt).getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            System.out.println(e);
        }

        try (PreparedStatement statement = connection.prepareStatement(sqlInsert)) {
            statement.setString(1, login);
            statement.setString(2, salt);
            statement.setBytes(3, hashedPassword);
            int rowsInserted = statement.executeUpdate();
            if (rowsInserted > 0) {
                return new SQLAnswer("User " + login + " was added", true);
            } else {
                return new SQLAnswer("Something mysterious just happened", false);
            }
        } catch (SQLException e) {
            System.err.println("Error registering user: " + e.getMessage());
            e.printStackTrace();
            return new SQLAnswer("DB Error", false);
        }
    }

    public SQLAnswer addDragon(String key, Dragon dragon, String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        try (PreparedStatement addStatement = connection.prepareStatement(sqlRequest, Statement.RETURN_GENERATED_KEYS)) {
            addStatement.setString(1, key);
            addStatement.setString(2, dragon.getName());
            addStatement.setDouble(3, dragon.getCoordinates().getX());
            addStatement.setLong(4, dragon.getCoordinates().getY());
            addStatement.setDate(5, Date.valueOf(dragon.getCreationDate()));
            addStatement.setInt(6, dragon.getAge());
            addStatement.setString(7, dragon.getColor().name());
            addStatement.setString(8, dragon.getType().name());
            addStatement.setString(9, dragon.getCharacter().name());
            if (dragon.getCave() == null) {
                addStatement.setNull(10, Types.NULL);
                addStatement.setNull(11, Types.NULL);
            } else {
                addStatement.setInt(10, dragon.getCave().getDepth());
                addStatement.setDouble(11, dragon.getCave().getNumberOfTreasures());
            }
            addStatement.setString(12, login);
            int rowsInserted = addStatement.executeUpdate();
            System.out.println(rowsInserted);
            ResultSet resultSet = addStatement.getGeneratedKeys();
            resultSet.next();
            if (rowsInserted > 0) {
                System.out.println("New dragon was added with id: " + resultSet.getString(1) + " by user " + login);
                return new SQLAnswer("Dragon with id " + resultSet.getString(1) + " was added", true);
            } else {
                return new SQLAnswer("Something mysterious just happened", false);
            }

        } catch (SQLException e) {
            System.out.println(e);
            return new SQLAnswer("DB Error", false);
        }
    }

    public boolean isDragonUsers(String dragonId, String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return false;
        }
        try (PreparedStatement selectStatement = connection.prepareStatement(sqlDragon)) {
            selectStatement.setString(1, dragonId);
            selectStatement.setString(2, login);
            ResultSet rs = selectStatement.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }
    }

    public SQLAnswer updateDragon(Dragon dragon, String dragonId, String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        if (!isDragonUsers(dragonId, login)) {
            return new SQLAnswer("Dragon not owned by user or does not exist", false);
        }

        String sql = "UPDATE dragons SET name = ?, x = ?, y = ?, creation_date = ?, age = ?, " +
                "color = ?::dragon_color, type = ?::dragon_type, character = ?::dragon_character, " +
                "depth = ?, number_of_treasures = ? WHERE id = ?";

        try (PreparedStatement updateStatement = connection.prepareStatement(sql)) {
            updateStatement.setString(1, dragon.getName());
            updateStatement.setDouble(2, dragon.getCoordinates().getX());
            updateStatement.setLong(3, dragon.getCoordinates().getY());
            updateStatement.setDate(4, Date.valueOf(dragon.getCreationDate()));
            updateStatement.setInt(5, dragon.getAge());
            updateStatement.setString(6, dragon.getColor().name());
            updateStatement.setString(7, dragon.getType().name());
            updateStatement.setString(8, dragon.getCharacter().name());

            if (dragon.getCave() == null) {
                updateStatement.setNull(9, Types.NULL);
                updateStatement.setNull(10, Types.NULL);
            } else {
                updateStatement.setInt(9, dragon.getCave().getDepth());
                updateStatement.setDouble(10, dragon.getCave().getNumberOfTreasures());
            }

            updateStatement.setString(11, dragonId);

            int rowsUpdated = updateStatement.executeUpdate();
            if (rowsUpdated > 0) {
                return new SQLAnswer("Dragon updated successfully", true);
            } else {
                return new SQLAnswer("No rows updated", false);
            }
        } catch (SQLException e) {
            e.printStackTrace();
            return new SQLAnswer("Database error during update", false);
        }
    }


    public SQLAnswer getAllDragons() {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        String sql = "SELECT * FROM dragons";
        try (Statement selectStatement = connection.createStatement();
             ResultSet resultSet = selectStatement.executeQuery(sql)) {
            return new SQLAnswer(resultSet, "All dragons result set", true);
        } catch (SQLException e) {
            e.printStackTrace();
            return new SQLAnswer("Error getting dragons", false);
        }
    }

    public SQLAnswer getUserDragons(String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        String sql = "SELECT * FROM dragons WHERE login = ?";
        try (PreparedStatement selectStatement = connection.prepareStatement(sql)) {
            selectStatement.setString(1, login);
            ResultSet resultSet = selectStatement.executeQuery();
            return new SQLAnswer(resultSet, "User dragons result set", true);
        } catch (SQLException e) {
            e.printStackTrace();
            return new SQLAnswer("Error fetching user dragons", false);
        }
    }

    private String getRandomString() {
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[random.nextInt(3, 9)];
        random.nextBytes(salt);
        return Base64.getEncoder().encodeToString(salt);
    }

    public boolean checkUserExists(String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return false;
        }
        String sqlCheck = "SELECT * FROM users WHERE login = ?";
        try (PreparedStatement checkStatement = connection.prepareStatement(sqlCheck)) {
            checkStatement.setString(1, login);
            ResultSet res = checkStatement.executeQuery();
            return res.next();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean validateUser(String login, String password) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return false;
        }
        String sql = "SELECT salt, password FROM users WHERE login = ?";
        try (PreparedStatement selectStatement = connection.prepareStatement(sql)) {
            selectStatement.setString(1, login);
            ResultSet resultSet = selectStatement.executeQuery();

            if (!resultSet.next()) {
                return false;
            }

            String storedSalt = resultSet.getString("salt");
            byte[] storedHash = resultSet.getBytes("password");

            MessageDigest sha = MessageDigest.getInstance("SHA-256");
            String pepper = "perpre ^_^";
            byte[] newHash = sha.digest((password + pepper + storedSalt).getBytes("UTF-8"));

            return MessageDigest.isEqual(storedHash, newHash);

        } catch (SQLException | NoSuchAlgorithmException | UnsupportedEncodingException e) {
            System.err.println("Error validating user: " + e.getMessage());
            return false;
        }
    }

    public SQLAnswer deleteDragon(String dragonId, String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        String sql = "DELETE FROM dragons WHERE id = ? AND login = ?";
        try (PreparedStatement deleteStatement = connection.prepareStatement(sql)) {
            deleteStatement.setString(1, dragonId);
            deleteStatement.setString(2, login);

            int rowsDeleted = deleteStatement.executeUpdate();

            if (rowsDeleted > 0) {
                return new SQLAnswer("Dragon deleted successfully", true);
            } else {
                return new SQLAnswer("Dragon not found or not owned by user", false);
            }
        } catch (SQLException e) {
            e.printStackTrace();
            return new SQLAnswer("Database error during deletion", false);
        }
    }

    public SQLAnswer deleteDragons(Set<String> dragonIds, String login) {
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return new SQLAnswer("Some problems occured in time of connection", false);
        }
        if (dragonIds == null || dragonIds.isEmpty()) {
            return new SQLAnswer("No dragons to delete", false);
        }

        String placeholders = String.join(",", Collections.nCopies(dragonIds.size(), "?"));
        String sql = "DELETE FROM dragons WHERE id IN (" + placeholders + ") AND login = ?";

        try (PreparedStatement deleteStatement = connection.prepareStatement(sql)) {
            int index = 1;

            for (String id : dragonIds) {
                deleteStatement.setString(index++, id);
            }

            deleteStatement.setString(index, login);

            int rowsDeleted = deleteStatement.executeUpdate();

            if (rowsDeleted > 0) {
                return new SQLAnswer("Deleted " + rowsDeleted + " dragons", true);
            } else {
                return new SQLAnswer("No dragons were deleted. Either they don't exist or are not owned by the user.", false);
            }
        } catch (SQLException e) {
            System.err.println("Error deleting dragons: " + e.getMessage());
            e.printStackTrace();
            return new SQLAnswer("Database error during deletion", false);
        }
    }


    public Map<String, Dragon> getDragonMap() {

        Map<String, Dragon> dragonMap = new HashMap<>();
        try {
            String line = Files.readAllLines(Paths.get("/home/studs/s435169/.pgpass")).get(0);
            String[] parts = line.split(":");
            connection = DriverManager.getConnection(url, parts[3], parts[4]);
        } catch (IOException | SQLException e) {
            return dragonMap;
        }

        String sql = "SELECT * FROM dragons";
        try (Statement selectStatement = connection.createStatement();
             ResultSet resultSet = selectStatement.executeQuery(sql)) {
            while (resultSet.next()) {
                String id = resultSet.getString("id");
                String name = resultSet.getString("name");
                double x = resultSet.getDouble("x");
                long y = resultSet.getLong("y");
                int age = resultSet.getInt("age");
                String colorStr = resultSet.getString("color");
                String typeStr = resultSet.getString("type");
                String characterStr = resultSet.getString("character");
                Integer depth = resultSet.getObject("depth", Integer.class);
                Double treasures = resultSet.getObject("number_of_treasures", Double.class);
                String login = resultSet.getString("login");

                Color color = Color.valueOf(colorStr);
                DragonType type = DragonType.valueOf(typeStr);
                DragonCharacter character = DragonCharacter.valueOf(characterStr);

                Coordinates coordinates = new Coordinates(x, y);
                DragonCave cave = (depth != null && treasures != null)
                        ? new DragonCave(depth, treasures)
                        : null;

                Dragon dragon = new Dragon(name, coordinates, age, color, type, character, cave);
                dragon.setOwnerLogin(login);

                dragonMap.put(id, dragon);
            }
        } catch (SQLException e) {
            e.printStackTrace();
            return dragonMap;
        }


        return dragonMap;
    }
}
// ./server/src/main/java/managers/ConnectionManager.java
package managers;

import Interpreters.ServerCommandInterpreter;
import handlers.ClientHandler;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Logger;

public class ConnectionManager {
    private static final Logger logger = Logger.getLogger(ConnectionManager.class.getName());

    private final ServerCommandInterpreter serverCommandInterpreter;
    private final int port;

    private final ExecutorService readPool = Executors.newCachedThreadPool();
    private final ExecutorService processPool = Executors.newCachedThreadPool();
    private final ExecutorService writePool = Executors.newCachedThreadPool();

    private ServerSocketChannel serverSocketChannel;
    private volatile boolean running = true;

    public ConnectionManager(int port, ServerCommandInterpreter serverCommandInterpreter) {
        this.port = port;
        this.serverCommandInterpreter = serverCommandInterpreter;
    }

    public void serve() {
        try {
            serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.bind(new InetSocketAddress("0.0.0.0" ,port));
            logger.info("Server started on port " + port);

            new Thread(this::handleConsoleInput).start();

            while (running) {
                try {
                    SocketChannel clientSocket = serverSocketChannel.accept();
                    readPool.execute(new ClientHandler(
                            clientSocket,
                            serverCommandInterpreter,
                            processPool,
                            writePool
                    ));
                } catch (IOException e) {
                    if (running) {
                        logger.severe("Error accepting client: " + e.getMessage());
                    }
                }
            }
        } catch (IOException e) {
            logger.severe("Server failed to start: " + e.getMessage());
            System.exit(1);
        } finally {
            shutdown();
        }
    }

    private void handleConsoleInput() {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            while (running) {
                if (reader.ready()) {
                    String line = reader.readLine();
                    processConsoleCommand(line);
                }
                Thread.sleep(100);
            }
        } catch (Exception e) {
            logger.severe("Error in console handler: " + e.getMessage());
        }
    }

    private void processConsoleCommand(String line) {
        String[] parts = line.trim().split("\\s+");
        if (parts.length == 0) return;

        if (parts[0].equals("exit")) {
            System.out.println("Shutting down server.");
            System.exit(0);
        } else {
            System.out.println("Unknown command: " + parts[0]);
        }

    }

    private void saveToFile(String filename) {
        processPool.execute(() -> {
            try {
                FileManager.saveCollectionToFile(filename, serverCommandInterpreter.getCollectionManager().getCollection());
            } catch (Exception e) {
                logger.severe("Error saving collection: " + e.getMessage());
            }
        });
    }

    private void shutdown() {
        running = false;
        readPool.shutdown();
        processPool.shutdown();
        writePool.shutdown();
        logger.info("Server shutdown complete.");
    }
}// ./server/src/main/java/managers/CollectionManager.java
package managers;

import structs.classes.Dragon;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

/**
 * Manager that manages collection
 */
public class CollectionManager {

    private static final Logger logger = Logger.getLogger(CollectionManager.class.getName());
    private final java.time.LocalDate initTime;
    Map<String, Dragon> collection = Collections.synchronizedMap(new HashMap<String, Dragon>());
    private DBManager dbManager;

    /**
     * May be initiated with no specific params
     */
    public CollectionManager() {
        this.initTime = java.time.LocalDate.now();
    }

    /**
     * May be initiated with JSON file. Uses {@link FileManager} for collection import.
     *
     * @param filename String of filename
     */
    public CollectionManager(String filename) {
        this();
        this.collection = FileManager.importCollectionFromFile(filename);
    }

    public CollectionManager(DBManager dbManager) {
        this();
        this.dbManager = dbManager;
        this.collection = dbManager.getDragonMap();
    }

    /**
     * Method that just creates a new empty collection
     */
    public void clearCollection() {
        this.collection = new HashMap<String, Dragon>();
    }

    /**
     * Used to return map info
     *
     * @return returns {@link Map}.
     */
    public Map<String, Object> getCollectionInfoMap() {
        Map<String, Object> tmpMap = new HashMap<>();
        tmpMap.put("Type", "HashMap");
        tmpMap.put("Date", this.initTime);
        tmpMap.put("ElementsQuantity", collection.size());
        return tmpMap;
    }

    /**
     * Adds element
     *
     * @param id     String, aka "key" in map
     * @param dragon Dragon object
     * @return returns result of operation. True, if element was added, and false if there is already one in collection.
     */
    public boolean addElement(String id, Dragon dragon) {
        if (collection.containsKey(id)) {
            return false;
        } else {
            collection.put(id, dragon);
            return true;
        }
    }

    public DBManager getDbManager() {
        return dbManager;
    }

    /**
     * Replaces element
     *
     * @param id     String, aka "key" for Map
     * @param dragon {@link Dragon} object
     */
    public void replaceElement(String id, Dragon dragon) {
        collection.replace(id, dragon);
    }

    /**
     * Some sort of wrapper for remove
     *
     * @param id String, aka "key" for Map
     */
    public void killElement(String id) {
        try {
            collection.remove(id);
        } catch (Throwable e) {
            System.out.println(e);
        }
    }

    /**
     * Small wrapper for Map get() method
     *
     * @param id String key
     * @return returns dragon
     */
    public Dragon getElement(String id) {
        return collection.get(id);
    }

    public boolean hasElement(String id) {
        return collection.containsKey(id);
    }

    public Map<String, Dragon> getCollection() {
        return collection;
    }

    public void setCollection(Map<String, Dragon> collection) {
        this.collection = collection;
    }


}
// ./server/src/main/java/managers/FileManager.java
package managers;

import structs.classes.Dragon;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Manager for files, Operates with way on how to save something and open it.
 */
public class FileManager {
    /**
     * Method to save collection to file. Uses Jackson.
     * @param filename name of file where to send
     * @param collection collection which should be stored
     */
    public static void saveCollectionToFile(String filename, Map<String, Dragon> collection){
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.registerModule(new JavaTimeModule());
            objectMapper.writeValue(new File(filename), collection);
            System.out.println("JSON создан успешно.");
        } catch (FileNotFoundException e) {
            System.out.println("Такой директории не существует.");
        } catch (IOException e){
            System.out.println("Произошла неопределённая проблема ввода/вывода.");
        }
    }

    /**
     * Opposite to save. Imports collection from file.
     * @param filename file, from which collection is imported
     * @return returns Map
     */
    public static Map<String, Dragon> importCollectionFromFile(String filename){
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.registerModule(new JavaTimeModule());
            Map<String, Dragon> collection = objectMapper.readValue(new File(filename), new TypeReference<Map<String,Dragon>>(){});
            System.out.println("JSON импортирован успешно.");
            return collection;
        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден. Создана пустая коллекция (проверьте имя файла).");
        } catch (IOException e){
            System.out.println("Произошла неопределённая проблема ввода/вывода. Создана пустая коллекция (проверьте файл с изначальной коллекцией).");
        }
        return new HashMap<String, Dragon>();
    }


}
// ./server/src/main/java/managers/DragonCreationManager.java
package managers;
import java.util.Iterator;
import java.util.NoSuchElementException;

import exceptions.NullForbiddenException;
import exceptions.RangeExceededException;
import structs.classes.Color;
import structs.classes.Coordinates;
import structs.classes.Dragon;
import structs.classes.DragonCave;
import structs.classes.DragonCharacter;
import structs.classes.DragonType;
import utils.InputChecker;

/**
 * Basically class that is used only for dragon creation process
 */
public class DragonCreationManager {
    /**
     * Static method that goes through the whole process of dragon creation.
     * @param input {@link Iterator} that would be used to access all the info about dragon
     * @return returns {@link Dragon} object
     */
    static public Dragon inputDragon(Iterator<String> input){
        String name = null;
        Double coordinateX = null;
        Long coordinateY = null;
        Integer age = null;
        Color color = null;
        DragonType type = null;
        DragonCharacter character = null;
        Integer caveDepth = null;
        Double treasures = null;
        String tmpInput = "";
        System.out.println("Name:");
        while(name == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                name = InputChecker.inputNonNullChecker(tmpInput);
            }
            catch (NullForbiddenException e){
                System.out.println(e);
            }

        }
        System.out.println("Coordinate X (double):");
        while(coordinateX == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                coordinateX = Double.parseDouble(tmpInput);
            }catch (NumberFormatException e){
                System.out.println("Неправильный формат числа");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Coordinate Y (Long, must be not null and less than 984):");
        while(coordinateY == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                coordinateY = InputChecker.inputRangeChecker(tmpInput, null, 984.0, true, Long.class);
            }catch (NumberFormatException e){
                System.out.println("Неправильный формат числа");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Age (integer, must be more than 0 and not null):");
        while(age == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                age = InputChecker.inputRangeChecker(tmpInput, 0.0, null,true, Integer.class);
            }catch (NumberFormatException e){
                System.out.println("Неправильный формат числа");
            }catch (RangeExceededException e){
                System.out.println(e);
            }
        }
        System.out.println("Color (enum, non null, options are: black, yellow, orange, brown):");
        while(color == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                color = InputChecker.getEnum(tmpInput, Color.class);
            }catch (NoSuchElementException e){
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Type (enum, non null, options are: water, underground, air, fire):");
        while(type == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                type = InputChecker.getEnum(tmpInput, DragonType.class);
            }catch (NoSuchElementException e){
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Character (enum, non null, options are: evil, chaotic_evil, fickle):");
        while(character == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                character = InputChecker.getEnum(tmpInput, DragonCharacter.class);
            }catch (NoSuchElementException e){
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Cave is being created. It might be null. \nIf at least one parameter will be null, cave will be null.");
        System.out.println("Cave depth (integer, might be null):");
        try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
        try {
            if(!tmpInput.trim().isBlank()){
                caveDepth = Integer.parseInt(tmpInput);
            }
        }catch (NumberFormatException e){
            System.out.println("Неправильный формат числа, записан null");
        }catch (Exception e) {
            System.out.println(e);
        }
        if(caveDepth != null) {
            System.out.println("Cave depth (double, might be null, at least 0.0):");
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                if (!tmpInput.trim().isBlank()) {
                    treasures = InputChecker.inputRangeChecker(tmpInput, 0.0, null, false, Double.class);
                }
            } catch (NumberFormatException e) {
                System.out.println("Неправильный формат числа, записан null");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        DragonCave dragonCave;
        if(caveDepth == null || treasures == null) {
            dragonCave = null;
        } else {
            dragonCave = new DragonCave(caveDepth, treasures);
        }


        return new Dragon(name,
                new Coordinates(coordinateX, coordinateY),
                age,
                color,
                type,
                character,
                dragonCave);
    }


}
// ./server/src/main/java/Main.java
import Interpreters.ServerCommandInterpreter;
import commands.*;
import managers.CollectionManager;
import managers.CommandManager;
import managers.ConnectionManager;
import managers.DBManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.logging.LogManager;
import java.util.logging.Logger;

class Main {
    private static final Logger logger = Logger.getLogger(Main.class.getName());

    public static void main(String[] args) {
        int port = 52947;

        File logDir = new File("logs");
        if (!logDir.exists()) {
            logDir.mkdirs();
        }

        try {
            LogManager.getLogManager().readConfiguration(Main.class.getClassLoader().getResourceAsStream("logging.properties"));
        } catch (Exception e) {
            logger.severe(e.getMessage());
        }
        DBManager dbm = new DBManager("localhost", 5432);

        CollectionManager collectionManager;
        if (args.length > 0) {
            collectionManager = new CollectionManager(args[0]);
        } else {
            collectionManager = new CollectionManager(dbm);
        }


        CommandManager commandManager = new CommandManager(collectionManager);

        commandManager.addCommand(new InfoCommand(collectionManager));
        commandManager.addCommand(new ShowCommand(collectionManager));
        commandManager.addCommand(new InsertCommand(collectionManager, commandManager));
        commandManager.addCommand(new UpdateCommand(collectionManager, commandManager));
        commandManager.addCommand(new RemoveKeyCommand(collectionManager));
        commandManager.addCommand(new ClearCommand(collectionManager));
        commandManager.addCommand(new SaveCommand(collectionManager));
        commandManager.addCommand(new ExitCommand());
        commandManager.addCommand(new RemoveGreaterCommand(collectionManager));
        commandManager.addCommand(new ReplaceIfLowerCommand(collectionManager, commandManager));
        commandManager.addCommand(new RemoveGreaterKeyCommand(collectionManager));
        commandManager.addCommand(new CountLessThanCharacterCommand(collectionManager));
        commandManager.addCommand(new PrintAscendingCommand(collectionManager));
        commandManager.addCommand(new PrintFieldDescendingTypeCommand(collectionManager));
        commandManager.addCommand(new RegisterCommand(commandManager, dbm));
        commandManager.addCommand(new LoginCommand(dbm));

        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        Iterator<String> it = in.lines().iterator();


        //dbm.registerUser("anon", "1234");
        //dbm.addDragon(new Dragon("Alex", new Coordinates(12.0, 12L), 12, Color.BLACK, DragonType.FIRE, DragonCharacter.CHAOTIC_EVIL), "anon");


        ServerCommandInterpreter serverCommandInterpreter = new ServerCommandInterpreter(commandManager, it);
        logger.info("CommandInterpreter started");
        ConnectionManager connectionManager = new ConnectionManager(port, serverCommandInterpreter);
        logger.info("Connection manager started with port: " + port);
        connectionManager.serve();


    /*
        "  - help : вывести справку по доступным командам\n" +
        "  - info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)\n" +
        "  - show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении\n" +
        "  - insert null {element} : добавить новый элемент с заданным ключом\n" +
        "  - update id {element} : обновить значение элемента коллекции, id которого равен заданному\n" +
        "  - remove_key null : удалить элемент из коллекции по его ключу\n" +
        "  - clear : очистить коллекцию\n" +
        "  - save : сохранить коллекцию в файл\n" +
        "  - execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.\n" +
        "  - exit : завершить программу (без сохранения в файл)\n" +
        "  - remove_greater {element} : удалить из коллекции все элементы, превышающие заданный\n" +
        "  - replace_if_lowe null {element} : заменить значение по ключу, если новое значение меньше старого\n" +
        "  - remove_greater_key null : удалить из коллекции все элементы, ключ которых превышает заданный\n" +
        "  - count_less_than_character character : вывести количество элементов, значение поля character которых меньше заданного\n" +
        "  - print_ascending : вывести элементы коллекции в порядке возрастания\n" +
        "  - print_field_descending_type : вывести значения поля type всех элементов в порядке убывания";
    */


    }
}
// ./server/src/main/java/Interpreters/ServerCommandInterpreter.java
package Interpreters;

import commands.BasicCommand;
import exceptions.CustomException;
import exceptions.EmptyRequestException;
import managers.CollectionManager;
import managers.CommandManager;
import structs.Packet;

import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Logger;

/**
 * One of main classes in program. Basically it is used for executing anything.
 */
public class ServerCommandInterpreter {

    private static final Logger logger = Logger.getLogger(ServerCommandInterpreter.class.getName());

    CommandManager commandManager;
    Iterator<String> it;
    Set<String> executableFiles = new HashSet<String>();

    /**
     * Basic or initial constructor is used for CLI input. In this case CommandInterpreter needs only {@link CommandManager} and {@link Iterator<String>}
     *
     * @param commandManager It is what it is
     * @param input          Should be Iterator with String.
     */
    public ServerCommandInterpreter(CommandManager commandManager, Iterator<String> input) {
        this.commandManager = commandManager;
        this.commandManager.setCommandInterpreter(this);
        this.it = input;
    }

    /**
     * In case you want to execute files, you might want to store them (just to exclude chanse infinite recursion). For this {@link Set} with filenames is stored.
     *
     * @param commandManager  It is what it is
     * @param input           Iterator with String
     * @param executableFiles Set with all the files that were executed before.
     */
    public ServerCommandInterpreter(CommandManager commandManager, Iterator<String> input, Set<String> executableFiles) {
        this.commandManager = commandManager;
        this.commandManager.setCommandInterpreter(this);
        this.it = input;
        this.executableFiles = executableFiles;
    }


    public String executeRequest(Packet packet) {
        if (packet == null) {
            throw new EmptyRequestException();
        }

        BasicCommand command = commandManager.getCommand(packet.getCommand());

        if (command != null) {
            try {
                logger.info("Client executed " + command.getName() + " command;");
                if (packet.isCommand()) {
                    return command.execute(packet.getArguments(), packet.getUser());
                }
                if (packet.isObjectCommand()) {
                    logger.info("Server got " + command.getName() + " command");
                    return command.execute(packet.getArgsObjectWrapper(), packet.getUser());
                }
            } catch (CustomException | FileNotFoundException e) {
                return e.toString();
            }
        }
        return "";
    }

    public Iterator<String> getInputIterator() {
        return it;
    }

    public CollectionManager getCollectionManager() {
        return this.commandManager.getCollectionManager();
    }

    public Set<String> getExecutableFiles() {
        return executableFiles;
    }

}// ./server/target/maven-status/maven-compiler-plugin/testCompile/default-testCompile/inputFiles.lst
// ./server/target/maven-status/maven-compiler-plugin/testCompile/default-testCompile/createdFiles.lst
// ./server/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/Interpreters/ServerCommandInterpreter.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/Main.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/async/AsyncRequestSender.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/BasicCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/ClearCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/CountLessThanCharacterCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/ExitCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/InfoCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/InsertCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/LoginCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/PrintAscendingCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/PrintFieldDescendingTypeCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/RegisterCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/RemoveGreaterCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/RemoveGreaterKeyCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/RemoveKeyCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/ReplaceIfLowerCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/SaveCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/ShowCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/commands/UpdateCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/CustomException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/EmptyRequestException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/InfiniteFileRecursion.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/NoSuchColorException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/NoSuchElementException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/NullArgsForbiddenException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/NullForbiddenException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/RangeExceededException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/exceptions/WrongRequestException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/handlers/ClientHandler.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/handlers/ProcessingHandler.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/handlers/ReadHandler.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/handlers/ResponseSender.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/managers/CollectionManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/managers/CommandManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/managers/ConnectionManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/managers/DBManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/managers/DragonCreationManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/managers/FileManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/utils/InputChecker.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/utils/RequestConstructor.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/utils/RequestResponseTool.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/server/src/main/java/utils/TypeComparator.java
// ./server/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst
commands/InsertCommand.class
commands/InfoCommand.class
managers/DragonCreationManager.class
commands/LoginCommand.class
handlers/ProcessingHandler.class
commands/BasicCommand.class
commands/ShowCommand.class
Main.class
exceptions/NullForbiddenException.class
exceptions/InfiniteFileRecursion.class
Interpreters/ServerCommandInterpreter.class
commands/SaveCommand.class
managers/FileManager.class
exceptions/NoSuchElementException.class
utils/RequestResponseTool.class
handlers/ReadHandler.class
commands/ClearCommand.class
commands/CountLessThanCharacterCommand.class
commands/RegisterCommand.class
async/AsyncRequestSender.class
commands/RemoveKeyCommand.class
commands/ExitCommand.class
managers/DBManager.class
handlers/ResponseSender.class
exceptions/CustomException.class
commands/PrintFieldDescendingTypeCommand.class
utils/RequestConstructor.class
exceptions/EmptyRequestException.class
commands/RemoveGreaterCommand.class
managers/FileManager$1.class
exceptions/WrongRequestException.class
managers/CommandManager.class
commands/UpdateCommand.class
commands/RemoveGreaterKeyCommand.class
handlers/ClientHandler.class
managers/ConnectionManager.class
commands/ReplaceIfLowerCommand.class
commands/PrintAscendingCommand.class
exceptions/NoSuchColorException.class
utils/TypeComparator.class
utils/InputChecker.class
exceptions/RangeExceededException.class
exceptions/NullArgsForbiddenException.class
managers/CollectionManager.class
// ./server/target/maven-archiver/pom.properties
artifactId=server
groupId=org.ITMO.s435169
version=v1
// ./server/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.ITMO.s435169</groupId>
        <artifactId>lab_8</artifactId>
        <version>v1</version>
    </parent>

    <artifactId>server</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.ITMO.s435169</groupId>
            <artifactId>common</artifactId>
            <version>v1</version>
        </dependency>
        <dependency>
            <groupId>commons-codec</groupId>
            <artifactId>commons-codec</artifactId>
            <version>1.16.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.8</version>
                <configuration>
                    <mainClass>hellofx/org.openjfx.App</mainClass>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>3.4.2</version>
                <configuration>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                    <archive>
                        <manifest>
                            <mainClass>Main</mainClass>
                        </manifest>
                    </archive>
                </configuration>
                <executions>
                    <execution>
                        <id>make-assembly</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>// ./src/main/resources/META-INF/MANIFEST.MF
Manifest-Version: 1.0
Main-Class: Main

// ./src/main/java/utils/TypeComparator.java
package utils;

import classes.Dragon;
import classes.DragonType;

import java.util.Comparator;

/**
 * Simple comparator that is used for default sort method in arrays.
 */
public class TypeComparator implements Comparator<Dragon> {
    @Override
    public int compare(Dragon d1, Dragon d2) {
        return d1.getType().compareTo(d2.getType());
    }
}
// ./src/main/java/utils/InputChecker.java
package utils;

import exceptions.*;
import exceptions.RangeExceededException;

import java.math.BigDecimal;

/**
 * Class that is used just to check user's input
 */
public class InputChecker {
    /**
     * Checks if string is blank
     * @param input String
     * @return String if it is fine
     * @throws NullForbiddenException if String is not fine.
     */
    static public String inputNonNullChecker(String input) throws NullForbiddenException {
        if(input.trim().isBlank()){
            throw new NullForbiddenException();
        }
        else{
            return input;
        }
    }

    /**
     * MAGNUM OPUS <br>
     * MEME ITSELF <br>
     * PIECE OF ART (no)
     * @param input String
     * @param min min value (might be null for <em>-inf</em>)
     * @param max max value (might be null for <i>+inf</i>)
     * @param nonNull boolean parameter to check number for null
     * @param returnType Class which has to be returned
     * @return returns object of class according to returnType
     * @throws NullForbiddenException cause null is bad
     * @throws RangeExceededException cause getting out of limits is halal
     */
    static public <T extends Number> T inputRangeChecker(String input, Double min, Double max, boolean nonNull, Class<T> returnType) throws NullForbiddenException, RangeExceededException {
        if(nonNull){
            if(input.trim().isBlank()){throw new NullForbiddenException();}
        }

        if(input.trim().isBlank()){return null;}

        BigDecimal inputValue = new BigDecimal(input);

        if (min != null && inputValue.compareTo(new BigDecimal(min)) < 0) {
            throw new RangeExceededException(min, max);
        }

        if (max != null && inputValue.compareTo(new BigDecimal(max)) > 0) {
            throw new RangeExceededException(min, max);
        }

        if(returnType == Integer.class){
            return returnType.cast(inputValue.intValue());
        }
        if(returnType == Double.class){
            return returnType.cast(inputValue.doubleValue());
        }
        if(returnType == Float.class){
            return returnType.cast(inputValue.floatValue());
        }
        if(returnType == Long.class){
            return returnType.cast(inputValue.longValue());
        }
        return null;
    }

    /**
     * Method that is used to pick enum, works in any way
     * @param input String
     * @param enumClass Generic. Put here Enum that you want
     * @return returns enum if it was picked correctly
     */
    public static <E extends Enum<E>> E getEnum(String input, Class<E> enumClass) {
        try {
            return Enum.valueOf(enumClass, input.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new NoSuchElementException();
        }
    }
}
// ./src/main/java/commands/RemoveKeyCommand.java
package commands;

import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;


/**
 * Removes element by key. That's all
 */
public class RemoveKeyCommand extends BasicCommand{
    public RemoveKeyCommand(CollectionManager collectionManager){
        super("remove_key", "remove_key null : удалить элемент из коллекции по его ключу", collectionManager);
    }

    /**
     * Deletes it via {@link managers.CommandManager}
     * @param args an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException doesn't like when input is blank.
     * @throws NoSuchElementException thrown when no such element was found in collection.
     */
    @Override
    public void execute(String[] args) throws NullArgsForbiddenException, NoSuchElementException {
        int deleted = 0;
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String masterId = args[0];

        if(collectionManager.hasElement(masterId)){
            collectionManager.killElement(masterId);
            System.out.println("Элемент " + masterId + " удалён успешно.");
        }else{
            throw new NoSuchElementException();
        }
    }

}
// ./src/main/java/commands/RemoveGreaterKeyCommand.java
package commands;

import classes.Dragon;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;

import java.util.HashMap;
import java.util.Map;

/**
 * Removes elements with key greater than this one
 */
public class RemoveGreaterKeyCommand extends BasicCommand{
    public RemoveGreaterKeyCommand(CollectionManager collectionManager){
        super("remove_greater_key", "remove_greater_key null : удалить из коллекции все элементы, ключ которых превышает заданный", collectionManager);
    }


    @Override
    public void execute(String[] args) throws NullArgsForbiddenException {
        int deleted = 0;

        if(args.length == 0){
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String masterId = args[0];
        Map<String, Dragon> originalCollection = collectionManager.getCollection();
        Map<String, Dragon> newCollection = new HashMap<String, Dragon>(originalCollection);
        for(String comparableElement : collectionManager.getCollection().keySet()){
            if(masterId.equals(comparableElement)){
                continue;
            }
            if(masterId.compareTo(comparableElement) > 0){
                newCollection.remove(comparableElement);
                deleted++;
            }
        }
        collectionManager.setCollection(newCollection);
        System.out.println("Deleted " + deleted + " objects ^_^");
    }
}
// ./src/main/java/commands/RemoveGreaterCommand.java
package commands;

import classes.Dragon;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;

import java.util.HashMap;
import java.util.Map;

/**
 * Removes greater elements (gets initial element by id)
 */
public class RemoveGreaterCommand extends  BasicCommand{
    public RemoveGreaterCommand(CollectionManager collectionManager){
        super("remove_greater", "remove_greater {element} : удалить из коллекции все элементы, превышающие заданный", collectionManager);
    }

    /**
     * Uses its {@link CollectionManager} and would remind me of <b>RUST SUPREMACY</b> till the end of my life.
     * @param args an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException thrown when no args were provided.
     */
    @Override
    public void execute(String[] args) throws NullArgsForbiddenException {
        int deleted = 0;
        if(args.length == 0){
            throw new NullArgsForbiddenException();
        }
        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String input = args[0];
        Dragon masterElement = collectionManager.getElement(input);


        if(masterElement == null){
            System.out.println("Такого элемента нет");
            return;
        }
        Map<String, Dragon> originalCollection = collectionManager.getCollection();
        Map<String, Dragon> newCollection = new HashMap<String, Dragon>(originalCollection);
        for(Map.Entry<String, Dragon> comparableElement : originalCollection.entrySet()){
            if(masterElement.equals(comparableElement.getValue())){
                continue;
            }
            if(masterElement.compareTo(comparableElement.getValue()) > 0){
                newCollection.remove(comparableElement.getKey());
                deleted++;
            }
        }
        collectionManager.setCollection(newCollection);
        System.out.println("Deleted " + deleted + " objects ^_^");
    }
}
// ./src/main/java/commands/ShowCommand.java
package commands;

import classes.Dragon;
import managers.CollectionManager;

import java.util.Map;

/**
 * Shows the collection
 */
public class ShowCommand extends BasicCommand{
    public ShowCommand(CollectionManager collectionManager) {
        super("show", "show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении", collectionManager);
    }

    /**
     * Uses its {@link CollectionManager} to access map.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public void execute(String[] args){
        Map<String, Dragon> localMap = this.collectionManager.getCollection();
        for (var pair: localMap.entrySet()){
            System.out.println("Key (" + pair.getKey() +")" + ":");
            System.out.println("\t" + pair.getValue().toString().replaceAll("\n", "\n\t") + "\n");

        }
    }
}
// ./src/main/java/commands/PrintFieldDescendingTypeCommand.java
package commands;

import classes.Dragon;
import managers.CollectionManager;
import utils.TypeComparator;

import java.util.ArrayList;
import java.util.List;

/**
 * Outputs id : type
 */

public class PrintFieldDescendingTypeCommand extends BasicCommand{
    public PrintFieldDescendingTypeCommand(CollectionManager collectionManager) {
        super("print_field_descending_type", "print_field_descending_type : вывести значения поля type всех элементов в порядке убывания", collectionManager);
    }

    /**
     * Uses default List sort({@link TypeComparator})
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public void execute(String[] args){
        List<Dragon> localList = new ArrayList<Dragon>(this.collectionManager.getCollection().values());
        localList.sort(new TypeComparator());
        for (var dragon: localList){
            System.out.println(dragon.getId() + " : " + dragon.getType().toString());

        }
    }
}
// ./src/main/java/commands/PrintAscendingCommand.java
package commands;

import classes.Dragon;
import managers.CollectionManager;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;


/**
 * Outputs all the elements stored in its {@link CollectionManager} in ascending order
 */
public class PrintAscendingCommand extends BasicCommand{
    public PrintAscendingCommand(CollectionManager collectionManager) {
        super("print_ascending","print_ascending : вывести элементы коллекции в порядке возрастания", collectionManager);
    }


    /**
     * Uses basic {@link List} sort(null) method.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public void execute(String[] args) {
        List<Dragon> localList = new ArrayList<Dragon>(this.collectionManager.getCollection().values());
        localList.sort(null);
        for (var dragon: localList){

            System.out.println(dragon.toString().replaceAll("\n", "\n\t") + "\n");

        }
    }
}
// ./src/main/java/commands/HelpCommand.java
package commands;

import managers.CommandManager;

/**
 * Command that outputs name and description for all the commands in its {@link CommandManager}.
 */
public class HelpCommand extends BasicCommand {
    CommandManager commandManager;

    public HelpCommand(CommandManager commandManager){
        super("help", "help : вывести справку по доступным командам");
        this.commandManager = commandManager;
    }

    /**
     * Gets all the commands that were registered in its {@link CommandManager}.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */

    @Override
    public void execute(String[] args) {
        for(var command : commandManager.getCommandsMap().entrySet()){
            System.out.println("  - " + command.getValue().getDescription());
        }
    }
}
// ./src/main/java/commands/SaveCommand.java
package commands;


import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.FileManager;

/**
 * Used to save something to file.
 */
public class SaveCommand extends BasicCommand{
    public SaveCommand(CollectionManager collectionManager){
        super("save", "save : сохранить коллекцию в файл", collectionManager);
    }


    /**
     * fun fact - all the errors are getting catched in {@link FileManager}.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException thrown when no args were provided.
     */
    @Override
    public void execute(String[] args) throws NullArgsForbiddenException {

        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        FileManager.saveCollectionToFile(args[0], collectionManager.getCollection());

    }


}
// ./src/main/java/commands/CountLessThanCharacterCommand.java
package commands;

import classes.Dragon;
import classes.DragonCharacter;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import utils.InputChecker;

import java.util.Map;

/**
 * Outputs amount of elements in which character field contains value less than given
 */
public class CountLessThanCharacterCommand extends BasicCommand {
    public CountLessThanCharacterCommand(CollectionManager collectionManager){
        super("count_less_than_character", "count_less_than_character character : вывести количество элементов, значение поля character которых меньше заданного", collectionManager);
        }

    /**
     * Checks your input with {@link InputChecker}, goes through an entrySet and outputs a number.
     * @param args an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException thrown when no args were given when needed.
     * @throws IllegalArgumentException thrown if such character enum type does not exist. Check {@link DragonCharacter}
     */
    @Override
    public void execute(String[] args) throws NullArgsForbiddenException, IllegalArgumentException {

        if(args.length == 0){
            throw new NullArgsForbiddenException();
        }
        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }


        DragonCharacter character = InputChecker.getEnum(args[0], DragonCharacter.class);

        int amount = 0;
        Map<String, Dragon> map = collectionManager.getCollection();
        for(var entry : map.entrySet()){
            if(entry.getValue().getCharacter().compareTo(character) < 0){
                amount++;
            }
        }
        System.out.println(amount);
    }

}
// ./src/main/java/commands/ClearCommand.java
package commands;

import managers.CollectionManager;

/**
 * Command to clear the collection.
 */
public class ClearCommand extends BasicCommand {
    public ClearCommand(CollectionManager collectionManager){
        super("clear", "clear : очистить коллекцию", collectionManager);
    }

    /**
     * Basically executes {@link CollectionManager} method in its {@link CollectionManager}.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public void execute(String[] args){
        collectionManager.clearCollection();
        System.out.println("Collection was cleared successfully!");
    }

}
// ./src/main/java/commands/ReplaceIfLowerCommand.java
package commands;

import classes.Dragon;
import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import managers.DragonCreationManager;


/**
 * Replaces all the elements that are lower
 */
public class ReplaceIfLowerCommand extends BasicCommand{
    CommandManager commandManager;
    public ReplaceIfLowerCommand(CollectionManager collectionManager, CommandManager commandManager){
        super("replace_if_lowe", "replace_if_lowe null {element} : заменить значение по ключу, если новое значение меньше старого", collectionManager);
        this.commandManager = commandManager;
    }


    /**
     * Uses basic {@link CollectionManager}
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException - basically do not give empty input
     * @throws NoSuchElementException - basically didn't find an element
     */
    @Override
    public void execute(String[] args) throws NullArgsForbiddenException, NoSuchElementException {
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }
        String inputId = args[0];
        if(collectionManager.hasElement(inputId)){
            Dragon dragon = DragonCreationManager.inputDragon(commandManager.getCommandInterpreter().getInputIterator());
            if (dragon == null){
                return;
            }
            if(collectionManager.getElement(inputId).compareTo(dragon) < 0) {
                collectionManager.replaceElement(inputId, dragon);
            }
            else{
                System.out.println("New dragon is not less than new one, nothing has changed :)");
            }
        }else{
            throw new NoSuchElementException();
        }
    }
}
// ./src/main/java/commands/UpdateCommand.java
package commands;

import classes.Dragon;
import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import managers.DragonCreationManager;

/**
 * Used for updating element with specific id
 */
public class UpdateCommand extends BasicCommand{
    CommandManager commandManager;
    public UpdateCommand(CollectionManager collectionManager, CommandManager commandManager){
        super("update", "update id {element} : обновить значение элемента коллекции, id которого равен заданному", collectionManager);
        this.commandManager = commandManager;
    }


    /**
     * Uses both {@link CommandManager} to get iterator and {@link CollectionManager} for access to db
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException - we hate it when you don't know what to put in command
     * @throws NoSuchElementException - we hate it when you put some crap in command
     */

    @Override
    public void execute(String[] args) throws NullArgsForbiddenException, NoSuchElementException {
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        String inputId = args[0];
        if(collectionManager.hasElement(inputId)){
            Dragon dragon = DragonCreationManager.inputDragon(commandManager.getCommandInterpreter().getInputIterator());
            if (dragon == null){
                return;
            }
            collectionManager.replaceElement(inputId, dragon);
        }else{
            throw new NoSuchElementException();
        }
    }
}
// ./src/main/java/commands/InsertCommand.java
package commands;

import Interpreters.CommandInterpreter;
import classes.Dragon;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import managers.DragonCreationManager;

import java.util.Arrays;

/**
 * Command that is used for adding some stuff in collection. Operates with both {@link CommandManager} and {@link CollectionManager}.
 */

public class InsertCommand extends BasicCommand{
    CommandManager commandManager;
    public InsertCommand(CollectionManager collectionManager, CommandManager commandManager){
        super("insert", "insert null {element} : добавить новый элемент с заданным ключом", collectionManager);
        this.commandManager = commandManager;
    }


    /**
     * Uses specific {@link DragonCreationManager} and some Iterators magic <i>*being meguka is suffering*</i>
     * @param args an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException thrown when no args were provided.
     */
    @Override
    public void execute(String[] args) throws NullArgsForbiddenException {

        if(args.length == 0){
            throw new NullArgsForbiddenException();
        }
        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }
        String id = args[0];




        if(collectionManager.hasElement(id)){
            System.out.println("Element with such name exists already! If you will continue, it will be overwritten!\nContinue? [y/N]:");
            String input = commandManager.getCommandInterpreter().getInputIterator().next();
            if (input.trim().isBlank() || input.equalsIgnoreCase("n")){
                return;
            }
        }

        Dragon dragon = DragonCreationManager.inputDragon(commandManager.getCommandInterpreter().getInputIterator());
        if(dragon == null){
            return;
        }
        collectionManager.addElement(id, dragon);


    }



}
// ./src/main/java/commands/InfoCommand.java
package commands;

import managers.CollectionManager;

import java.util.Map;

/**
 * Command, that briefly takes basic info from the {@link CollectionManager} and ouputs it into console.
 */

public class InfoCommand extends  BasicCommand{

    public InfoCommand(CollectionManager collectionManager){
        super("info","info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)", collectionManager);
    }

    /**
     * Collects info from {@link CollectionManager} and outputs it.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public void execute(String[] args){
        Map<String, Object> map = collectionManager.getCollectionInfoMap();

        System.out.println("Тип коллекции: " + map.get("Type").toString() + ".\n" +
                "Дата инициализации коллекции: " + map.get("Date").toString() + ".\n"+
                "Количество элементов в коллекции: " + map.get("ElementsQuantity").toString()
        );
    }
}
// ./src/main/java/commands/BasicCommand.java
package commands;

import exceptions.CustomException;
import exceptions.InfiniteFileRecursion;
import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;

import java.io.FileNotFoundException;

/**
 * Abstract class for all the commands. Contains exceptional name and description, execute() method.
 *
 */

abstract public class BasicCommand {

    private final String name;
    private final String description;
    protected CollectionManager collectionManager;
    public BasicCommand(String name, String description) {
        this.name = name;
        this.description = description;
    }
    public BasicCommand(String name, String description, CollectionManager collectionManager){
        this(name,description);
        this.collectionManager = collectionManager;
    }


    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }




    /**
     * Execute function stands for basic command execution process. Execute method is being executed in CommandManager.
      * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    public void execute(String[] args) throws CustomException, FileNotFoundException {
        System.out.println(this.name + " is not done yet. ^_^");

    }
}
// ./src/main/java/commands/ExitCommand.java
package commands;

/**
 * Some sort of wrapper for System.exit(0).
 */

public class ExitCommand extends BasicCommand{

    public ExitCommand(){
        super("exit", "exit : завершить программу (без сохранения в файл)");
    }

    /**
     * {@link System} check out an exit method
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public void execute(String[] args) {
        System.exit(0);
    }
}// ./src/main/java/commands/ExecuteScriptCommand.java
package commands;

import Interpreters.CommandInterpreter;
import exceptions.InfiniteFileRecursion;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * Command that is used to execute scripts.
 */

public class ExecuteScriptCommand extends BasicCommand{
    CommandManager commandManager;
    //place command manager in here

    /**
     * Its constructor gets {@link CommandManager}, that manages commands and contains {@link CommandInterpreter}
     * @param commandManager - thing that manages commands, operates with them. Needed for some commands to access managers and stuff.
     */

    public ExecuteScriptCommand(CommandManager commandManager){
        super("execute_script","execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.");
        this.commandManager = commandManager;
    }


    /**
     * In this command it basically checks if there's no recursion and starts new instance of {@link CommandInterpreter}, that gets things done
     * @param args an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws InfiniteFileRecursion throws just in case if user lost his mind and tries to create infinite file recursion.
     * @throws NullArgsForbiddenException thrown when no arguments were provided (they are exceptional).
     */
    @Override
    public void execute(String[] args) throws InfiniteFileRecursion, NullArgsForbiddenException, FileNotFoundException {
        if(args.length == 0){
            throw new NullArgsForbiddenException();
        }
        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }


        String filename = args[0];
        if(commandManager.getCommandInterpreter().executedFile(filename)){
            throw new InfiniteFileRecursion();
        }
        else{
            Set<String> executableFiles = commandManager.getCommandInterpreter().getExecutableFiles();
            executableFiles.add(filename);
            Scanner sc = new Scanner(new File(filename)).useDelimiter("\n");
            new CommandInterpreter(commandManager, sc, executableFiles).fileExecution();
            executableFiles.remove(filename);

        }
    }


}
// ./src/main/java/exceptions/CustomException.java
package exceptions;

/**
 * Class that is being caught by {@link Interpreters.CommandInterpreter}, use it to create new exceptions for your commands
 */
public abstract class CustomException extends RuntimeException {
    public CustomException() {}

    /**
     * Any exception that is being caught during runtime will be displayed using toString().
     * @return String that explains main idea of exception
     */
    public String toString(){
        return "CustomException";
    }
}
// ./src/main/java/exceptions/NullArgsForbiddenException.java
package exceptions;

/**
 * Exception that is usually thrown by {@link utils.InputChecker}.
 */
public class NullArgsForbiddenException extends CustomException {
    @Override
    public String toString(){
        return "Null obtained when command needs input!";
    }
}
// ./src/main/java/exceptions/NullForbiddenException.java
package exceptions;

public class NullForbiddenException extends CustomException {
    public NullForbiddenException() {
    }

    @Override
    public String toString(){
        return "Null obtained in non-null field!";
    }

}
// ./src/main/java/exceptions/RangeExceededException.java
package exceptions;


/**
 * Exception that you can use to remind user to use specific range of numbers
 */
public class RangeExceededException extends CustomException {//checked/unchecked
    Double min;
    Double max;

    /**
     * You have to set borders in constructor of this exception. If you need only one-side restriction, put null for +-inf.
     * @param min Double (min num in range)
     * @param max Double (max num in range)
     */
    public RangeExceededException(Double min, Double max) {
        this.max = max;
        this.min = min;
    }

    @Override
    public String toString() {
        if(min == null){
            return "Expected range is less than " + max;
        }
        if(max == null){
            return "Expected range is bigger than " + min;
        }
        return "Expected range is a number between " + min + " and " + max;
    }
}
// ./src/main/java/exceptions/NoSuchColorException.java
package exceptions;

/**
 * Exception that is being thrown when user tries to pick color that does not exist
 */
public class NoSuchColorException extends CustomException {

  @Override
  public String toString(){
    return "Seems like there is no such color";
  }
}
// ./src/main/java/exceptions/NoSuchElementException.java
package exceptions;

/**
 * Exception that is being thrown when element was not found in collection
 */
public class NoSuchElementException extends CustomException {
    @Override
    public String toString(){
        return "No such element in collection";
    }
}
// ./src/main/java/exceptions/InfiniteFileRecursion.java
package exceptions;


/**
 * Exception that is used to notify user when recursion occurs
 */
public class InfiniteFileRecursion extends CustomException {
    @Override
    public String toString(){
        return "Seems like you are trying to create a file loop. Bruh, for what?";
    }
}
// ./src/main/java/out/production/lab5/lab5.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>// ./src/main/java/managers/CommandManager.java
package managers;

import Interpreters.CommandInterpreter;
import commands.BasicCommand;

import java.util.HashMap;
import java.util.Map;

/**
 * Class that manages all the commands. Actually, that's some sort of a wrapper for Map ^_^
 * Maybe got no sense but still I love it and I think it is some sort of Controller in MVC.
 *
 *
*/
public class CommandManager {
    private final Map<String, BasicCommand> commandsMap = new HashMap<String, BasicCommand>();
    CollectionManager collectionManager;
    CommandInterpreter commandInterpreter;

    /**
     * Constructor for class
     * @param collectionManager basically a {@link CollectionManager}
     */
    public CommandManager(CollectionManager collectionManager) {
        this.collectionManager = collectionManager;
    }

    /**
     * Adds command in command manager.
     * @param command object of {@link BasicCommand} children
     */
    public void addCommand(BasicCommand command) {
        this.commandsMap.put(command.getName(), command);

    }

    public Map<String, BasicCommand> getCommandsMap() {
        return this.commandsMap;
    }

    public CollectionManager getCollectionManager(){
        return this.collectionManager;
    }

    public void setCommandInterpreter(CommandInterpreter commandInterpreter) {
        this.commandInterpreter = commandInterpreter;
    }

    public CommandInterpreter getCommandInterpreter() {
        return commandInterpreter;
    }


    public BasicCommand getCommand(String name){
        return commandsMap.get(name);
    }


}
// ./src/main/java/managers/CollectionManager.java
package managers;

import classes.*;

import java.util.HashMap;
import java.util.Map;

/**
 * Manager that manages collection
 */
public class CollectionManager {

    Map<String, Dragon> collection = new HashMap<String, Dragon>();
    private final java.time.LocalDate initTime;

    /**
     * May be initiated with no specific params
     */
    public CollectionManager(){
        this.initTime = java.time.LocalDate.now();
    }

    /**
     * May be initiated with JSON file. Uses {@link FileManager} for collection import.
     * @param filename String of filename
     */
    public CollectionManager(String filename){
        this();
        this.collection = FileManager.importCollectionFromFile(filename);
    }

    /**
     * Method that just creates a new empty collection
     */
    public void clearCollection(){
        this.collection = new HashMap<String, Dragon>();
    }

    /**
     * Used to return map info
     * @return returns {@link Map}.
     */
    public Map<String, Object> getCollectionInfoMap(){
        Map<String, Object> tmpMap = new HashMap<>();
        tmpMap.put("Type", "HashMap");
        tmpMap.put("Date", this.initTime);
        tmpMap.put("ElementsQuantity", collection.size());
        return tmpMap;
    }

    /**
     * Adds element
     * @param id String, aka "key" in map
     * @param dragon Dragon object
     * @return returns result of operation. True, if element was added, and false if there is already one in collection.
     */
    public boolean addElement(String id, Dragon dragon){
        if(collection.containsKey(id)){
            return false;
        }else{
            collection.put(id, dragon);
            return true;
        }
    }

    /**
     * Replaces element
     * @param id String, aka "key" for Map
     * @param dragon {@link Dragon} object
     */
    public void replaceElement(String id, Dragon dragon){
        collection.replace(id,dragon);
    }

    /**
     * Some sort of wrapper for remove
     * @param id String, aka "key" for Map
     */
    public void killElement(String id){
        try {
            collection.remove(id);
        }catch (Throwable e){
            System.out.println(e);
        }
    }

    /**
     * Small wrapper for Map get() method
     * @param id String key
     * @return returns dragon
     */
    public Dragon getElement(String id){
        return collection.get(id);
    }

    public boolean hasElement(String id){
        return collection.containsKey(id);
    }

    public Map<String, Dragon> getCollection(){
        return collection;
    }

    public void setCollection(Map<String, Dragon> collection){
        this.collection = collection;
    }


}
// ./src/main/java/managers/FileManager.java
package managers;

import classes.Dragon;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Manager for files, Operates with way on how to save something and open it.
 */
public class FileManager {
    /**
     * Method to save collection to file. Uses Jackson.
     * @param filename name of file where to send
     * @param collection collection which should be stored
     */
    public static void saveCollectionToFile(String filename, Map<String, Dragon> collection){
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.registerModule(new JavaTimeModule());
            objectMapper.writeValue(new File(filename), collection);
            System.out.println("JSON создан успешно.");
        } catch (FileNotFoundException e) {
            System.out.println("Такой директории не существует.");
        } catch (IOException e){
            System.out.println("Произошла неопределённая проблема ввода/вывода.");
        }
    }

    /**
     * Opposite to save. Imports collection from file.
     * @param filename file, from which collection is imported
     * @return returns Map
     */
    public static Map<String, Dragon> importCollectionFromFile(String filename){
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.registerModule(new JavaTimeModule());
            Map<String, Dragon> collection = objectMapper.readValue(new File(filename), new TypeReference<Map<String,Dragon>>(){});
            System.out.println("JSON импортирован успешно.");
            return collection;
        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден. Создана пустая коллекция (проверьте имя файла).");
        } catch (IOException e){
            System.out.println("Произошла неопределённая проблема ввода/вывода. Создана пустая коллекция (проверьте файл с изначальной коллекцией).");
        }
        return new HashMap<String, Dragon>();
    }


}
// ./src/main/java/managers/DragonCreationManager.java
package managers;

import classes.*;
import exceptions.NullForbiddenException;
import exceptions.RangeExceededException;
import utils.InputChecker;

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Basically class that is used only for dragon creation process
 */
public class DragonCreationManager {
    /**
     * Static method that goes through the whole process of dragon creation.
     * @param input {@link Iterator} that would be used to access all the info about dragon
     * @return returns {@link Dragon} object
     */
    static public Dragon inputDragon(Iterator<String> input){
        String name = null;
        Double coordinateX = null;
        Long coordinateY = null;
        Integer age = null;
        Color color = null;
        DragonType type = null;
        DragonCharacter character = null;
        Integer caveDepth = null;
        Double treasures = null;
        String tmpInput = "";
        System.out.println("Name:");
        while(name == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                name = InputChecker.inputNonNullChecker(tmpInput);
            }
            catch (NullForbiddenException e){
                System.out.println(e);
            }

        }
        System.out.println("Coordinate X (double):");
        while(coordinateX == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                coordinateX = Double.parseDouble(tmpInput);
            }catch (NumberFormatException e){
                System.out.println("Неправильный формат числа");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Coordinate Y (Long, must be not null and less than 984):");
        while(coordinateY == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                coordinateY = InputChecker.inputRangeChecker(tmpInput, null, 984.0, true, Long.class);
            }catch (NumberFormatException e){
                System.out.println("Неправильный формат числа");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Age (integer, must be more than 0 and not null):");
        while(age == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                age = InputChecker.inputRangeChecker(tmpInput, 0.0, null,true, Integer.class);
            }catch (NumberFormatException e){
                System.out.println("Неправильный формат числа");
            }catch (RangeExceededException e){
                System.out.println(e);
            }
        }
        System.out.println("Color (enum, non null, options are: black, yellow, orange, brown):");
        while(color == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                color = InputChecker.getEnum(tmpInput, Color.class);
            }catch (NoSuchElementException e){
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Type (enum, non null, options are: water, underground, air, fire):");
        while(type == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                type = InputChecker.getEnum(tmpInput, DragonType.class);
            }catch (NoSuchElementException e){
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Character (enum, non null, options are: evil, chaotic_evil, fickle):");
        while(character == null) {
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                character = InputChecker.getEnum(tmpInput, DragonCharacter.class);
            }catch (NoSuchElementException e){
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            }catch (Exception e){
                System.out.println(e);
            }
        }
        System.out.println("Cave is being created. It might be null. \nIf at least one parameter will be null, cave will be null.");
        System.out.println("Cave depth (integer, might be null):");
        try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
        try {
            if(!tmpInput.trim().isBlank()){
                caveDepth = Integer.parseInt(tmpInput);
            }
        }catch (NumberFormatException e){
            System.out.println("Неправильный формат числа, записан null");
        }catch (Exception e) {
            System.out.println(e);
        }
        if(caveDepth != null) {
            System.out.println("Cave depth (double, might be null, at least 0.0):");
            try{
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                if (!tmpInput.trim().isBlank()) {
                    treasures = InputChecker.inputRangeChecker(tmpInput, 0.0, null, false, Double.class);
                }
            } catch (NumberFormatException e) {
                System.out.println("Неправильный формат числа, записан null");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        DragonCave dragonCave;
        if(caveDepth == null || treasures == null) {
            dragonCave = null;
        } else {
            dragonCave = new DragonCave(caveDepth, treasures);
        }


        return new Dragon(name,
                new Coordinates(coordinateX, coordinateY),
                age,
                color,
                type,
                character,
                dragonCave);
    }


}
// ./src/main/java/Main.java
import Interpreters.CommandInterpreter;
import commands.*;
import managers.CollectionManager;
import managers.CommandManager;
import managers.FileManager;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Iterator;

class Main {
    public static void main(String[] args) {
        CollectionManager collectionManager;
        if(args.length > 0){
            collectionManager = new CollectionManager(args[0]);
        }
        else{
            collectionManager = new CollectionManager();
        }
        CommandManager commandManager = new CommandManager(collectionManager);

        commandManager.addCommand(new HelpCommand(commandManager));
        commandManager.addCommand(new InfoCommand(collectionManager));
        commandManager.addCommand(new ShowCommand(collectionManager));
        commandManager.addCommand(new InsertCommand(collectionManager, commandManager));
        commandManager.addCommand(new UpdateCommand(collectionManager, commandManager));
        commandManager.addCommand(new RemoveKeyCommand(collectionManager));
        commandManager.addCommand(new ClearCommand(collectionManager));
        commandManager.addCommand(new SaveCommand(collectionManager));
        commandManager.addCommand(new ExecuteScriptCommand(commandManager));
        commandManager.addCommand(new ExitCommand());
        commandManager.addCommand(new RemoveGreaterCommand(collectionManager));
        commandManager.addCommand(new ReplaceIfLowerCommand(collectionManager, commandManager));
        commandManager.addCommand(new RemoveGreaterKeyCommand(collectionManager));
        commandManager.addCommand(new CountLessThanCharacterCommand(collectionManager));
        commandManager.addCommand(new PrintAscendingCommand(collectionManager));
        commandManager.addCommand(new PrintFieldDescendingTypeCommand(collectionManager));

        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        Iterator<String> it = in.lines().iterator();

        CommandInterpreter commandInterpreter = new CommandInterpreter(commandManager, it);


        commandInterpreter.loop_stdin();
    /*
        "  - help : вывести справку по доступным командам\n" +
        "  - info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)\n" +
        "  - show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении\n" +
        "  - insert null {element} : добавить новый элемент с заданным ключом\n" +
        "  - update id {element} : обновить значение элемента коллекции, id которого равен заданному\n" +
        "  - remove_key null : удалить элемент из коллекции по его ключу\n" +
        "  - clear : очистить коллекцию\n" +
        "  - save : сохранить коллекцию в файл\n" +
        "  - execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.\n" +
        "  - exit : завершить программу (без сохранения в файл)\n" +
        "  - remove_greater {element} : удалить из коллекции все элементы, превышающие заданный\n" +
        "  - replace_if_lowe null {element} : заменить значение по ключу, если новое значение меньше старого\n" +
        "  - remove_greater_key null : удалить из коллекции все элементы, ключ которых превышает заданный\n" +
        "  - count_less_than_character character : вывести количество элементов, значение поля character которых меньше заданного\n" +
        "  - print_ascending : вывести элементы коллекции в порядке возрастания\n" +
        "  - print_field_descending_type : вывести значения поля type всех элементов в порядке убывания";
    */




    }
}
// ./src/main/java/Interpreters/CommandInterpreter.java
package Interpreters;

import java.io.FileNotFoundException;
import java.nio.file.NoSuchFileException;
import java.util.*;
import commands.*;
import exceptions.*;
import exceptions.NoSuchElementException;
import managers.*;

/**
 * One of main classes in program. Basically it is used for executing anything.
 */
public class CommandInterpreter {

    CommandManager commandManager;
    Iterator<String> it;
    Set<String> executableFiles = new HashSet<String>();

    /**
     * Basic or initial constructor is used for CLI input. In this case CommandInterpreter needs only {@link CommandManager} and {@link Iterator<String>}
     * @param commandManager It is what it is
     * @param input Should be Iterator with String.
     */
    public CommandInterpreter(CommandManager commandManager, Iterator<String> input) {
        this.commandManager = commandManager;
        this.commandManager.setCommandInterpreter(this);
        this.it = input;
    }

    /**
     * In case you want to execute files, you might want to store them (just to exclude chanse infinite recursion). For this {@link Set} with filenames is stored.
     * @param commandManager It is what it is
     * @param input Iterator with String
     * @param executableFiles Set with all the files that were executed before.
     */
    public CommandInterpreter(CommandManager commandManager, Iterator<String> input, Set<String> executableFiles) {
        this.commandManager = commandManager;
        this.commandManager.setCommandInterpreter(this);
        this.it = input;
        this.executableFiles = executableFiles;
    }

    /**
     * Checks if this file was in execution sequence
     * @param filename name of file that we want to check
     * @return returns true if it did execute that file
     */
    public boolean executedFile(String filename){
        return executableFiles.contains(filename);
    }

    /**
     * Main loop that gets your input from CLI
     */
    public void loop_stdin() {
        System.out.print(">>> ");
        while (it.hasNext()) {
            String line = it.next();
            executeLine(line);
            System.out.print(">>> ");
        }
    }

    /**
     * loop_stdin() modification for file execution. Does not print out ">>> "
     */
    public void fileExecution(){
        while (it.hasNext()) {
            String line = it.next();
            executeLine(line);
        }
    }

    /**
     * Method that is used for initial execution of line. <br>
     * <i>public</i>, to be used in lab7 to execute line in server. <br>
     * <br>
     * <b>Note</b> that this method <b>DOES NOT</b> do anything with command args. It just splits line by spaces, uses first word as command and parses rest to the command. <br>
     * <b>Note</b> that it may send array of 0 length to your command. You should check input for such an option.
     * @param line basically a line with command.
     */
    public void executeLine(String line){

            if (line.trim().isBlank()) {
                return;
            }
            String[] parts = line.trim().split("[ \t]+");
            String commandName = parts[0];

            BasicCommand command = commandManager.getCommand(commandName);

            String[] args = (parts.length > 1) ? Arrays.copyOfRange(parts, 1, parts.length) : new String[0];
            if (command != null) {
                try {
                command.execute(args);
            }catch (CustomException | FileNotFoundException e){
                System.out.println(e);
            }
            } else {
                System.out.println("Unknown command: " + commandName);
            }


    }

    public Iterator<String> getInputIterator() {
        return it;
    }
    public CollectionManager getCollectionManager(){
        return this.commandManager.getCollectionManager();
    }
    public Set<String> getExecutableFiles() {
        return executableFiles;
    }

}// ./src/main/java/lab5.iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>// ./app/src/main/resources/gui/i18n/messages_pl_PL.properties
// ./app/src/main/resources/gui/i18n/messages_en_IN.properties
// ./app/src/main/resources/gui/i18n/messages.properties
app.title=Dragon Collection Viewer
filter.label=Filter:
filter.prompt=Type to filter...
button.refresh=Refresh
user.unregistered=Guest
button.registerLogin=Login / Register

# Command Buttons
command.info=Info
command.show=Show
command.insert=Insert
command.update=Update
command.remove_key=Remove Key
command.remove_greater=Remove Greater
command.replace_if_lower=Replace If Lower

# Table Columns
column.key=Key
column.owner=Owner
column.name=Name
column.creationDate=Creation Date
column.age=Age
column.color=Color
column.type=Type
column.character=Character
column.depth=Cave Depth
column.treasures=Treasures

# Alerts
alert.info.title=Collection Info
alert.info.content=Type: %s\nInitialization Date: %s\nNumber of elements: %d
alert.error.title=Error
alert.error.notOwner=Sorry, but you cannot modify someone else's dragon.
alert.warning.title=Action Forbidden
alert.warning.notLoggedIn=You must be logged in to perform this action.
alert.result.title=Execution Result

# Create/Update Form
form.title.create=Create New Dragon
form.title.update=Update Dragon: %s
form.label.name=Name:
form.label.key=Key:
# ... etc.// ./app/src/main/resources/gui/i18n/messages_ru_RU.properties
# ?????
app.title=\u041F\u0440\u043E\u0441\u043C\u043E\u0442\u0440 \u043A\u043E\u043B\u043B\u0435\u043A\u0446\u0438\u0438
filter.label=??????:
filter.prompt=????...
button.refresh=?????????????
user.unregistered=?????
button.registerLogin=???? / ???????????

# ?????? ??????
command.info=????
command.show=???
command.insert=????????
command.update=????????
command.remove_key=??????? ?? ?????
command.remove_greater=????? ??????????
command.replace_if_lower=???????? ???? ??????

# ??????? ???????
column.key=????
column.owner=??????
column.name=???
column.x=X
column.y=Y
column.creationDate=????
column.age=???????
column.color=????
column.type=???
column.character=?????
column.depth=??????? ????
column.treasures=??????????

# ??????????
alert.info.title=???? ? ?????????
alert.info.content=???: %s\n???? ?????????????: %s\n?????????? ?????????: %d
alert.error.title=??????
alert.error.notOwner=?????, ?? ????? ???????? ???? ????? ????????
alert.warning.title=???????
alert.warning.notLoggedIn=??????? ??????????, ????? ????? ?? ??????
alert.result.title=????????? ????????

# ????? ????????/??????????
form.title.create=??????? ?????? ???????
form.title.update=???????? ???????: %s
form.label.name=???:
form.label.key=????:
# ... ? ??? ????? ??? ???? ????? ?????// ./app/src/main/resources/gui/i18n/messages_is_IS.properties
// ./app/src/main/java/utils/InputTools.java
package utils;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class InputTools {


    public static String[] splitLine(String line) {
        return line.trim().split("[ \t]+");
    }


    public static Object parseObjectResponse(SocketChannel channel) {
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        try {
            int bytesRead = channel.read(buffer);
            if (bytesRead == -1) {
                return null;
            }

            buffer.flip();
            byte[] data = new byte[buffer.remaining()];
            buffer.get(data);

            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);
            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);

            return objectInputStream.readObject();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("Input/output error: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Received corrupted or unknown object: " + e.getMessage());
        }
        return null;
    }
}
// ./app/src/main/java/utils/TypeComparator.java
package utils;

import structs.classes.Dragon;

import java.util.Comparator;

/**
 * Simple comparator that is used for default sort method in arrays.
 */
public class TypeComparator implements Comparator<Dragon> {
    @Override
    public int compare(Dragon d1, Dragon d2) {
        return d1.getType().compareTo(d2.getType());
    }
}
// ./app/src/main/java/utils/RequestConstructor.java
package utils;

import java.util.Map;
import java.util.TreeMap;

import commands.BasicCommand;
import structs.Packet;
import structs.PacketType;
import structs.User;
import structs.classes.Dragon;
import structs.wrappers.DragonDisplayWrapper;

public class RequestConstructor {

    public static Packet createRequest(BasicCommand command, String[] args, Object object, User user) {
        if (object == null) {
            return new Packet(PacketType.ARGS_COMMAND, command.getName(), args, user);
        } else if (object instanceof Dragon) {
            return new Packet(PacketType.OBJECT_COMMAND, command.getName(), args, object, user);
        } else if (object instanceof User) {
            return new Packet(PacketType.OBJECT_COMMAND, command.getName(), args, (User) object);
            //was PacketType.AUTH
        } else if (object instanceof DragonDisplayWrapper){
            return new Packet(PacketType.OBJECT_COMMAND, command.getName(), args, object, user);
        }

        return null;
    }
///метод для запроса актуальной версии коллекции
    public static Packet createRequest(){
        return new Packet(PacketType.MAP, new TreeMap<>());
    }
}
// ./app/src/main/java/utils/RequestResponseTool.java
package utils;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

import exceptions.WrongRequestException;
import structs.Packet;

public class RequestResponseTool {
    static public boolean sendPacket(SocketChannel channel, Packet packet) throws IOException {
        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        try (ObjectOutputStream objectStream = new ObjectOutputStream(byteStream)) {
            objectStream.writeObject(packet);
            objectStream.flush();
            byte[] data = byteStream.toByteArray();

            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
            lengthBuffer.putInt(data.length);
            lengthBuffer.flip();
            channel.write(lengthBuffer);

            channel.write(ByteBuffer.wrap(data));
            return true;
        } catch (NotSerializableException e) {
            System.out.println("Вы положили что-то не сериализуемое в реквест");
            return false;
        }
    }

    static public Packet getPacket(SocketChannel channel) throws WrongRequestException {
        try {
            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);
            while (lengthBuffer.hasRemaining()) {
                if (channel.read(lengthBuffer) == -1) {
                    return null;
                }
            }
            lengthBuffer.flip();
            int length = lengthBuffer.getInt();
                ByteBuffer buffer = ByteBuffer.allocate(length);
                



                while (buffer.hasRemaining()) {
                    if (channel.read(buffer) == -1) {
                        throw new EOFException("Unexpected end of stream");
                    }
                }

                buffer.flip();

                ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(buffer.array());
                ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);

                Object object = objectInputStream.readObject();

                if (object instanceof Packet) {
                    return (Packet) object;
                } else {
                    throw new WrongRequestException();
                }
        } catch (IOException e) {
            System.out.println("Input/output error: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Received corrupted or unknown object: " + e.getMessage());
        }
        return null;
    }

}
// ./app/src/main/java/utils/InputChecker.java
package utils;

import exceptions.*;
import exceptions.RangeExceededException;

import java.math.BigDecimal;

/**
 * Class that is used just to check user's input
 */
public class InputChecker {
    /**
     * Checks if string is blank
     * @param input String
     * @return String if it is fine
     * @throws NullForbiddenException if String is not fine.
     */
    static public String inputNonNullChecker(String input) throws NullForbiddenException {
        if(input.trim().isBlank()){
            throw new NullForbiddenException();
        }
        else{
            return input;
        }
    }

    /**
     * MAGNUM OPUS <br>
     * MEME ITSELF <br>
     * PIECE OF ART (no)
     * @param input String
     * @param min min value (might be null for <em>-inf</em>)
     * @param max max value (might be null for <i>+inf</i>)
     * @param nonNull boolean parameter to check number for null
     * @param returnType Class which has to be returned
     * @return returns object of class according to returnType
     * @throws NullForbiddenException cause null is bad
     * @throws RangeExceededException cause getting out of limits is halal
     */
    static public <T extends Number> T inputRangeChecker(String input, Double min, Double max, boolean nonNull, Class<T> returnType) throws NullForbiddenException, RangeExceededException {
        if(nonNull){
            if(input.trim().isBlank()){throw new NullForbiddenException();}
        }

        if(input.trim().isBlank()){return null;}

        BigDecimal inputValue = new BigDecimal(input);

        if (min != null && inputValue.compareTo(new BigDecimal(min)) < 0) {
            throw new RangeExceededException(min, max);
        }

        if (max != null && inputValue.compareTo(new BigDecimal(max)) > 0) {
            throw new RangeExceededException(min, max);
        }

        if(returnType == Integer.class){
            return returnType.cast(inputValue.intValue());
        }
        if(returnType == Double.class){
            return returnType.cast(inputValue.doubleValue());
        }
        if(returnType == Float.class){
            return returnType.cast(inputValue.floatValue());
        }
        if(returnType == Long.class){
            return returnType.cast(inputValue.longValue());
        }
        return null;
    }

    /**
     * Method that is used to pick enum, works in any way
     * @param input String
     * @param enumClass Generic. Put here Enum that you want
     * @return returns enum if it was picked correctly
     */
    public static <E extends Enum<E>> E getEnum(String input, Class<E> enumClass) {
        try {
            return Enum.valueOf(enumClass, input.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new NoSuchElementException();
        }
    }
}
// ./app/src/main/java/commands/local/HelpCommand.java
package commands.local;

import commands.BasicCommand;
import managers.CommandManager;

/**
 * Command that outputs name and description for all the commands in its {@link CommandManager}.
 */
public class HelpCommand extends BasicCommand {
    CommandManager commandManager;

    public HelpCommand(CommandManager commandManager){
        super("help", "help : вывести справку по доступным командам");
        this.commandManager = commandManager;
    }

    /**
     * Gets all the commands that were registered in its {@link CommandManager}.
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */

    @Override
    public Object execute(String[] args) {
        System.out.println("System commands:");
        for(var command : commandManager.getLocalCommandsMap().entrySet()){
            System.out.println("  - " + command.getValue().getDescription());
        }
        System.out.println("Server commands:");
        for(var command : commandManager.getServerCommandsMap().entrySet()){
            System.out.println("  - " + command.getValue().getDescription());
        }
        return null;
    }
}
// ./app/src/main/java/commands/local/ExitCommand.java
package commands.local;

import commands.BasicCommand;

/**
 * Some sort of wrapper for System.exit(0).
 */

public class ExitCommand extends BasicCommand {

    public ExitCommand(){
        super("exit", "exit : завершить программу (без сохранения в файл)");
    }

    /**
     * {@link System} check out an exit method
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    @Override
    public Object execute(String[] args) {
        System.exit(0);return null;
    }
}// ./app/src/main/java/commands/local/ExecuteScriptCommand.java
package commands.local;

import commands.BasicCommand;
import exceptions.InfiniteFileRecursion;
import exceptions.NullArgsForbiddenException;
import managers.ClientManager;
import managers.CommandManager;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Set;

/**
 * Command that is used to execute scripts.
 */

public class ExecuteScriptCommand extends BasicCommand {
    CommandManager commandManager;
    //place command manager in here


    public ExecuteScriptCommand(CommandManager commandManager){
        super("execute_script","execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.");
        this.commandManager = commandManager;
    }


    @Override
    public Object execute(String[] args) throws InfiniteFileRecursion, NullArgsForbiddenException, FileNotFoundException {
        if(args.length == 0){
            throw new NullArgsForbiddenException();
        }
        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }


        String filename = args[0];
        if(commandManager.getClientManager().executedFile(filename)){
            throw new InfiniteFileRecursion();
        }
        else{
            Set<String> executableFiles = commandManager.getClientManager().getExecutableFiles();
            executableFiles.add(filename);
            Scanner sc = new Scanner(new File(filename)).useDelimiter("\n");
            new ClientManager(sc, commandManager.getClientManager().getHostname(), commandManager.getClientManager().getPort(), commandManager, executableFiles, commandManager.getClientManager().getSocketChannel()).runFile();
            executableFiles.remove(filename);

        }
        return null;
    }


}
// ./app/src/main/java/commands/server/RemoveKeyCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;


/**
 * Removes element by key. That's all
 */
public class RemoveKeyCommand extends BasicCommand {
    public RemoveKeyCommand(CollectionManager collectionManager){
        super("remove_key", "remove_key null : удалить элемент из коллекции по его ключу", collectionManager);
    }


}
// ./app/src/main/java/commands/server/RemoveGreaterKeyCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Removes elements with key greater than this one
 */
public class RemoveGreaterKeyCommand extends BasicCommand {
    public RemoveGreaterKeyCommand(CollectionManager collectionManager) {
        super("remove_greater_key", "remove_greater_key null : удалить из коллекции все элементы, ключ которых превышает заданный", collectionManager);
    }


}
// ./app/src/main/java/commands/server/RemoveGreaterCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Removes greater elements (gets initial element by id)
 */
public class RemoveGreaterCommand extends BasicCommand {
    public RemoveGreaterCommand(CollectionManager collectionManager) {
        super("remove_greater", "remove_greater {element} : удалить из коллекции все элементы, превышающие заданный", collectionManager);
    }


}
// ./app/src/main/java/commands/server/ShowCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Shows the collection
 */
public class ShowCommand extends BasicCommand {
    public ShowCommand(CollectionManager collectionManager) {
        super("show", "show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении", collectionManager);
    }


}
// ./app/src/main/java/commands/server/PrintFieldDescendingTypeCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Outputs id : type
 */

public class PrintFieldDescendingTypeCommand extends BasicCommand {
    public PrintFieldDescendingTypeCommand(CollectionManager collectionManager) {
        super("print_field_descending_type", "print_field_descending_type : вывести значения поля type всех элементов в порядке убывания", collectionManager);
    }


}
// ./app/src/main/java/commands/server/RegisterCommand.java
package commands.server;

import commands.BasicCommand;
import exceptions.NullForbiddenException;
import managers.CommandManager;
import structs.User;
import utils.InputChecker;

import java.io.IOError;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class RegisterCommand extends BasicCommand {
    CommandManager commandManager;

    public RegisterCommand(CommandManager commandManager) {
        super("register", "register: Буквально команда которая тебя зарегистрирует, лол");
        this.commandManager = commandManager;
    }

    @Override
    public Object execute(String[] args) {
        User user = commandManager.getClientManager().getUser();
        if (user != null) {
            System.out.println("U r registered already, bruh");
            return null;
        }

        String login = null;
        String password = null;
        String tmpInput;
        Iterator<String> it = commandManager.getClientManager().getInputIterator();
        System.out.println("Your login:");

        while (login == null) {
            try {
                tmpInput = it.next();
            } catch (NoSuchElementException e) {
                System.out.println("Registration process was interrupted, nothing was added");
                return null;
            }
            try {
                login = InputChecker.inputNonNullChecker(tmpInput);
            } catch (NullForbiddenException e) {
                System.out.println(e);
            }

        }
        System.out.println("Your password:");
        while (password == null) {
            try {
                tmpInput = it.next();
            } catch (IOError e) {
                System.out.println("Registration process was interrupted, nothing was added");
                return null;
            }
            try {
                password = InputChecker.inputNonNullChecker(tmpInput);
            } catch (NullForbiddenException e) {
                System.out.println(e);
            }

        }
        user = new User(login, password);
        this.commandManager.getClientManager().setUser(user);
        return user;

    }
}
// ./app/src/main/java/commands/server/PrintAscendingCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;


/**
 * Outputs all the elements stored in its {@link CollectionManager} in ascending order
 */
public class PrintAscendingCommand extends BasicCommand {
    public PrintAscendingCommand(CollectionManager collectionManager) {
        super("print_ascending","print_ascending : вывести элементы коллекции в порядке возрастания", collectionManager);
    }


}
// ./app/src/main/java/commands/server/CountLessThanCharacterCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Outputs amount of elements in which character field contains value less than given
 */
public class CountLessThanCharacterCommand extends BasicCommand {
    public CountLessThanCharacterCommand(CollectionManager collectionManager){
        super("count_less_than_character", "count_less_than_character character : вывести количество элементов, значение поля character которых меньше заданного", collectionManager);
        }


}
// ./app/src/main/java/commands/server/ClearCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Command to clear the collection.
 */
public class ClearCommand extends BasicCommand {
    public ClearCommand(CollectionManager collectionManager){
        super("clear", "clear : очистить коллекцию", collectionManager);
    }

}
// ./app/src/main/java/commands/server/ReplaceIfLowerCommand.java
package commands.server;

import commands.BasicCommand;
import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import managers.DragonCreationManager;
import structs.classes.Dragon;


/**
 * Replaces all the elements that are lower
 */
public class ReplaceIfLowerCommand extends BasicCommand {
    CommandManager commandManager;

    public ReplaceIfLowerCommand(CollectionManager collectionManager, CommandManager commandManager) {
        super("replace_if_lowe", "replace_if_lowe null {element} : заменить значение по ключу, если новое значение меньше старого", collectionManager);
        this.commandManager = commandManager;
    }


    /**
     * Uses basic {@link CollectionManager}
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException - basically do not give empty input
     * @throws NoSuchElementException     - basically didn't find an element
     */
    @Override
    public Object execute(String[] args) throws NullArgsForbiddenException, NoSuchElementException {
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        Dragon dragon = DragonCreationManager.inputDragon(commandManager.getClientManager().getInputIterator());

        return dragon;

    }
}
// ./app/src/main/java/commands/server/UpdateCommand.java
package commands.server;

import commands.BasicCommand;
import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import managers.DragonCreationManager;
import structs.classes.Dragon;

/**
 * Used for updating element with specific id
 */
public class UpdateCommand extends BasicCommand {
    CommandManager commandManager;

    public UpdateCommand(CollectionManager collectionManager, CommandManager commandManager) {
        super("update", "update id {element} : обновить значение элемента коллекции, id которого равен заданному", collectionManager);
        this.commandManager = commandManager;
    }


    /**
     * Uses both {@link CommandManager} to get iterator and {@link CollectionManager} for access to db
     *
     * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException - we hate it when you don't know what to put in command
     * @throws NoSuchElementException     - we hate it when you put some crap in command
     */

    @Override
    public Object execute(String[] args) throws NullArgsForbiddenException, NoSuchElementException {
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }

        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }

        Dragon dragon = DragonCreationManager.inputDragon(commandManager.getClientManager().getInputIterator());

        return dragon;
    }
}
// ./app/src/main/java/commands/server/InsertCommand.java
package commands.server;

import commands.BasicCommand;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;
import managers.DragonCreationManager;
import structs.classes.Dragon;

/**
 * Command that is used for adding some stuff in collection. Operates with both {@link CommandManager} and {@link CollectionManager}.
 */

public class InsertCommand extends BasicCommand {
    CommandManager commandManager;

    public InsertCommand(CollectionManager collectionManager, CommandManager commandManager) {
        super("insert", "insert null {element} : добавить новый элемент с заданным ключом", collectionManager);
        this.commandManager = commandManager;
    }


    /**
     * Uses specific {@link DragonCreationManager} and some Iterators magic <i>*being meguka is suffering*</i>
     *
     * @param args an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     * @throws NullArgsForbiddenException thrown when no args were provided.
     */
    @Override
    public Object execute(String[] args) throws NullArgsForbiddenException {
        if (args.length == 0) {
            throw new NullArgsForbiddenException();
        }
        if (args[0].trim().isBlank()) {
            throw new NullArgsForbiddenException();
        }
        String id = args[0];

        Dragon dragon = DragonCreationManager.inputDragon(commandManager.getClientManager().getInputIterator());
        if (dragon == null) {
            return null;
        }
        return dragon;


    }


}
// ./app/src/main/java/commands/server/InfoCommand.java
package commands.server;

import commands.BasicCommand;
import managers.CollectionManager;

/**
 * Command, that briefly takes basic info from the {@link CollectionManager} and ouputs it into console.
 */

public class InfoCommand extends BasicCommand {

    public InfoCommand(CollectionManager collectionManager){
        super("info","info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)", collectionManager);
    }

}
// ./app/src/main/java/commands/server/LoginCommand.java
package commands.server;

import commands.BasicCommand;
import exceptions.NullForbiddenException;
import managers.CommandManager;
import structs.User;
import utils.InputChecker;

import java.io.Console;
import java.io.IOError;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class LoginCommand extends BasicCommand {
    CommandManager commandManager;

    public LoginCommand(CommandManager commandManager) {
        super("login", "login: Буквально команда которая тебя залогинит");
        this.commandManager = commandManager;
    }

    @Override
    public Object execute(String[] args) {
        String login = null;
        String password = null;
        String tmpInput;
        Iterator<String> it = commandManager.getClientManager().getInputIterator();
        System.out.println("Your login:");

        while (login == null) {
            try {
                tmpInput = it.next();
            } catch (NoSuchElementException e) {
                System.out.println("Login process was interrupted, nothing was added");
                return null;
            }
            try {
                login = InputChecker.inputNonNullChecker(tmpInput);
            } catch (NullForbiddenException e) {
                System.out.println(e);
            }

        }
        System.out.println("Your password:");
        Console console = System.console();
        char[] passwordArray;
        while (password == null) {
            try {
                passwordArray = console.readPassword();
            } catch (IOError e) {
                System.out.println("Login process was interrupted, nothing was added");
                return null;
            }
            try {
                password = InputChecker.inputNonNullChecker(new String(passwordArray));
            } catch (NullForbiddenException e) {
                System.out.println(e);
            }

        }
        User user = new User(login, password);
        this.commandManager.getClientManager().setUser(user);
        return user;

    }
}
// ./app/src/main/java/commands/BasicCommand.java
package commands;

import exceptions.CustomException;
import exceptions.InfiniteFileRecursion;
import exceptions.NoSuchElementException;
import exceptions.NullArgsForbiddenException;
import managers.CollectionManager;
import managers.CommandManager;

import java.io.FileNotFoundException;

/**
 * Abstract class for all the commands. Contains exceptional name and description, execute() method.
 *
 */

abstract public class BasicCommand {

    private final String name;
    private final String description;
    protected CollectionManager collectionManager;
    public BasicCommand(String name, String description) {
        this.name = name;
        this.description = description;
    }
    public BasicCommand(String name, String description, CollectionManager collectionManager){
        this(name,description);
        this.collectionManager = collectionManager;
    }


    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }




    /**
     * Execute function stands for basic command execution process. Execute method is being executed in CommandManager.
      * @param args - an array of strings (words that were separated by spaces). Usually it is ignored in commands that do not need any args, and those who need, get only as much as they need (others are being ignored)
     */
    public Object execute(String[] args) throws CustomException, FileNotFoundException {
        return null;
    }

}
// ./app/src/main/java/exceptions/CustomException.java
package exceptions;

public abstract class CustomException extends RuntimeException {
    public CustomException() {}

    /**
     * Any exception that is being caught during runtime will be displayed using toString().
     * @return String that explains main idea of exception
     */
    public String toString(){
        return "CustomException";
    }
}
// ./app/src/main/java/exceptions/ConnectionInterruptedException.java
package exceptions;

public class ConnectionInterruptedException extends CustomException {
    @Override
    public String toString() {
        return "Соединение было прервано в процессе передачи информации.";
    }
}
// ./app/src/main/java/exceptions/WrongRequestException.java
package exceptions;

public class WrongRequestException extends CustomException {
    public WrongRequestException() {}

    @Override
    public String toString() {
        return "Seems like wrong request provided";
    }
}
// ./app/src/main/java/exceptions/NullArgsForbiddenException.java
package exceptions;

/**
 * Exception that is usually thrown by {@link utils.InputChecker}.
 */
public class NullArgsForbiddenException extends CustomException {
    @Override
    public String toString(){
        return "Null obtained when command needs input!";
    }
}
// ./app/src/main/java/exceptions/NullForbiddenException.java
package exceptions;

public class NullForbiddenException extends CustomException {
    public NullForbiddenException() {
    }

    @Override
    public String toString(){
        return "Null obtained in non-null field!";
    }

}
// ./app/src/main/java/exceptions/RangeExceededException.java
package exceptions;


/**
 * Exception that you can use to remind user to use specific range of numbers
 */
public class RangeExceededException extends CustomException {//checked/unchecked
    Double min;
    Double max;

    /**
     * You have to set borders in constructor of this exception. If you need only one-side restriction, put null for +-inf.
     * @param min Double (min num in range)
     * @param max Double (max num in range)
     */
    public RangeExceededException(Double min, Double max) {
        this.max = max;
        this.min = min;
    }

    @Override
    public String toString() {
        if(min == null){
            return "Expected range is less than " + max;
        }
        if(max == null){
            return "Expected range is bigger than " + min;
        }
        return "Expected range is a number between " + min + " and " + max;
    }
}
// ./app/src/main/java/exceptions/NoSuchColorException.java
package exceptions;

/**
 * Exception that is being thrown when user tries to pick color that does not exist
 */
public class NoSuchColorException extends CustomException {

  @Override
  public String toString(){
    return "Seems like there is no such color";
  }
}
// ./app/src/main/java/exceptions/NoSuchElementException.java
package exceptions;

/**
 * Exception that is being thrown when element was not found in collection
 */
public class NoSuchElementException extends CustomException {
    @Override
    public String toString(){
        return "No such element in collection";
    }
}
// ./app/src/main/java/exceptions/InfiniteFileRecursion.java
package exceptions;


/**
 * Exception that is used to notify user when recursion occurs
 */
public class InfiniteFileRecursion extends CustomException {
    @Override
    public String toString(){
        return "Seems like you are trying to create a file loop. Bruh, for what?";
    }
}
// ./app/src/main/java/managers/CommandManager.java
package managers;
import commands.BasicCommand;

import java.util.HashMap;
import java.util.Map;

/**
 * Class that manages all the commands. Actually, that's some sort of a wrapper for Map ^_^
 * Maybe got no sense but still I love it and I think it is some sort of Controller in MVC.
 *
 *
*/
public class CommandManager {
    private final Map<String, BasicCommand> localCommandsMap = new HashMap<String, BasicCommand>();
    private final Map<String, BasicCommand> serverCommandsMap = new HashMap<String, BasicCommand>();
    CollectionManager collectionManager;
    ClientManager clientManager;

    public CommandManager(CollectionManager collectionManager){
        this.collectionManager = collectionManager;
    }

    /**
     * Adds command in command manager.
     * @param command object of {@link BasicCommand} children
     */
    public void addLocalCommand(BasicCommand command) {
        this.localCommandsMap.put(command.getName(), command);
    }
    public void addServerCommand(BasicCommand command) {
        this.serverCommandsMap.put(command.getName(), command);
    }

    public boolean hasCommand(String command){
        return localCommandsMap.containsKey(command) || serverCommandsMap.containsKey(command);
    }

    public boolean isLocalCommand(String command){
        return localCommandsMap.containsKey(command);
    }


    public Map<String, BasicCommand> getLocalCommandsMap() {
        return this.localCommandsMap;
    }
    public Map<String, BasicCommand> getServerCommandsMap() {
        return this.serverCommandsMap;
    }

    public CollectionManager getCollectionManager(){
        return this.collectionManager;
    }

    public void setClientManager(ClientManager clientManager) {
        this.clientManager = clientManager;
    }

    public ClientManager getClientManager() {
        return clientManager;
    }


    public BasicCommand getCommand(String name){
        if(localCommandsMap.get(name) == null){
            return serverCommandsMap.get(name);
        }
        return localCommandsMap.get(name);
    }


}
// ./app/src/main/java/managers/ClientManager.java
package managers;

import exceptions.CustomException;
import structs.Packet;
import structs.User;
import utils.InputTools;
import utils.RequestConstructor;
import utils.RequestResponseTool;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.channels.SocketChannel;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class ClientManager {

    static int MAX_RECONNECT_ATTEMPTS = 5;
    static int RECONNECT_TIMEOUT = 2000; //millis

    Iterator<String> it;
    String hostname = "188.242.233.237";
    int port = 25947;
    CommandManager commandManager;
    Set<String> executableFiles = new HashSet<String>();
    boolean fileNotEmpty = true;
    SocketChannel socketChannel;
    User user = null;

    public ClientManager(Iterator<String> it, String hostname, int port, CommandManager commandManager) {
        this.it = it;
        this.hostname = hostname;
        this.port = port;
        this.commandManager = commandManager;
        commandManager.setClientManager(this);
    }

    public ClientManager(Iterator<String> it, String hostname, int port, CommandManager commandManager, Set<String> executableFiles, SocketChannel socketChannel) {
        this(it, hostname, port, commandManager);
        this.executableFiles = executableFiles;
        this.socketChannel = socketChannel;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public void run() {
        while (true) {
            try (SocketChannel channel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT)) {
                this.socketChannel = channel;
                handleConnection(channel);
            } catch (IOException e) {
                System.out.println("Похоже произошёл дисконнект. Переподключаемся. (после подключения введите команду снова)");
            }
        }
    }

    public void runFile() {
        boolean fileEnded = false;
        while (socketChannel.isConnected() && !fileEnded) {
            try {
                fileEnded = fileWriteOperation(socketChannel);
                if (!fileEnded) {
                    readOperation(socketChannel);
                }
            } catch (IOException e) {
                System.out.println("Похоже произошёл дисконнект. Переподключаемся.");
                socketChannel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT);
            }
        }
    }


    private void handleConnection(SocketChannel channel) throws IOException {
        while (channel.isConnected()) {
            writeOperation(channel);
            readOperation(channel);

        }
    }


    private void readOperation(SocketChannel channel) throws IOException {
        //System.out.println("read is awaited");
        try {
            Packet packet = RequestResponseTool.getPacket(channel);
            if (packet == null) {
                throw new IOException("Server closed the connection");
            }
            if (packet.isText()) {
                if (packet.getText().equals("no such user") || packet.getText().equals("wrong password")) {
                    this.user = null;
                }
                System.out.println(packet.getText());
            } else {
                System.out.println("Request can not be processed for now");
            }
        } catch (CustomException e) {
            System.out.println(e.toString());
        }

    }

    private void writeOperation(SocketChannel channel) throws IOException {
        String line;
        String command;
        String[] args;
        String[] list;
        boolean requestSent = false;
        while (!requestSent) {
            System.out.print(">>> ");
            if (it.hasNext()) {
                line = it.next();

                if (line.trim().isBlank()) {
                    continue;
                }
                list = InputTools.splitLine(line);
                if (!commandManager.hasCommand(list[0])) {
                    System.out.println("Unknown command: " + list[0]);
                    continue;
                }

                command = list[0];
                args = list.length > 1 ? Arrays.copyOfRange(list, 1, list.length) : new String[0];

                try {
                    if (commandManager.isLocalCommand(command)) {
                        commandManager.getCommand(command).execute(args);
                    } else {
                        Packet packet = RequestConstructor.createRequest(commandManager.getCommand(command), args, commandManager.getCommand(command).execute(args), user);

                        RequestResponseTool.sendPacket(channel, packet);
                        requestSent = true;
                    }
                } catch (CustomException e) {
                    System.out.println(e);
                } catch (FileNotFoundException e) {
                    System.out.println("File not found");
                }


            } else {
                System.out.println("\nInput finished. Suicide!");
                System.exit(1);
            }
        }
        //System.out.println("Waiting for response");
    }

    private boolean fileWriteOperation(SocketChannel channel) throws IOException {
        String line;
        String command;
        String[] args;
        String[] list;
        boolean requestSent = false;
        while (!requestSent) {
            if (it.hasNext()) {
                line = it.next();

                if (line.trim().isBlank()) {
                    continue;
                }
                list = InputTools.splitLine(line);
                if (!commandManager.hasCommand(list[0])) {
                    System.out.println("Unknown command: " + list[0]);
                    continue;
                }

                command = list[0];
                args = list.length > 1 ? Arrays.copyOfRange(list, 1, list.length) : new String[0];

                try {
                    if (commandManager.isLocalCommand(command)) {
                        commandManager.getCommand(command).execute(args);
                    } else {
                        Packet packet = RequestConstructor.createRequest(commandManager.getCommand(command), args, commandManager.getCommand(command).execute(args), user);
                        RequestResponseTool.sendPacket(channel, packet);
                        requestSent = true;
                    }
                } catch (CustomException e) {
                    System.out.println(e);
                } catch (FileNotFoundException e) {
                    System.out.println("File not found");
                }

            } else {
                System.out.println("\nFile execution finished!");
                return true;
            }
        }
        return false;
    }


    public Iterator<String> getInputIterator() {
        return it;
    }

    public void setIt(Iterator<String> it) {
        this.it = it;
    }

    public String getHostname() {
        return hostname;
    }

    public void setHostname(String hostname) {
        this.hostname = hostname;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public boolean executedFile(String filename) {
        return executableFiles.contains(filename);
    }


    public Set<String> getExecutableFiles() {
        return executableFiles;
    }

    public SocketChannel getSocketChannel() {
        return socketChannel;
    }
}
// ./app/src/main/java/managers/ConnectionManager.java
package managers;


import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

import static java.lang.Thread.sleep;

/**
 * A class for managing connections. Gets stuff needed, returns channels
 */
public class ConnectionManager {

    public static SocketChannel connectToServer(String hostname, int port, int MAX_RECONNECT_ATTEMPTS, int RECONNECT_TIMEOUT) {
        for (int i = 0; i < MAX_RECONNECT_ATTEMPTS; i++) {
            try {
                byte BYTE = 0x42;
                SocketChannel channel = SocketChannel.open(new InetSocketAddress(hostname, port));
                channel.configureBlocking(true);
                ByteBuffer buffer = ByteBuffer.allocate(1);
                buffer.put(BYTE);
                buffer.flip();
                channel.write(buffer);
                buffer.clear();
                int bytesRead = channel.read(buffer);
                if (bytesRead == -1) {
                    System.out.println("Server closed the connection.");
                    channel.close();
                    continue;
                } else if (bytesRead == 0) {
                    System.out.println("Соединение устанавливается. Попытка №" + (i + 1) + "/5");
                    try {
                        channel.close();
                        sleep(RECONNECT_TIMEOUT);
                    } catch (InterruptedException ex) {
                        throw new RuntimeException(ex);
                    }
                    continue;
                }

                buffer.flip();
                byte serverByte = buffer.get();
                if (serverByte == 0x43) {
                    System.out.println("Соединение установлено");
                    return channel;
                }

            } catch (IOException e) {
                System.out.println("Соединение устанавливается. Попытка №" + (i + 1) + "/5");
                try {
                    sleep(RECONNECT_TIMEOUT);
                } catch (InterruptedException ex) {
                    throw new RuntimeException(ex);
                }

            }
        }
        System.out.println("Соединение не установилось спустя 5 попыток. Обрываемся.");
        System.exit(1);
        return null;
    }
}

// ./app/src/main/java/managers/CollectionManager.java
package managers;

import structs.Packet;
import structs.classes.Dragon;
import utils.RequestConstructor;
import utils.RequestResponseTool;

import java.io.IOException;
import java.nio.channels.SocketChannel;
import java.util.HashMap;
import java.util.Map;

import javafx.collections.FXCollections;

/**
 * Manager that manages collection
 */
public class CollectionManager {

    private final java.time.LocalDate initTime;
    Map<String, Dragon> collection = FXCollections.observableHashMap();
    static int MAX_RECONNECT_ATTEMPTS = 5;
    static int RECONNECT_TIMEOUT = 2000; //millis
    String hostname = "188.242.233.237";
    int port = 52947;
    SocketChannel channel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT);



    /**
     * May be initiated with no specific params
     */
    public CollectionManager() {
        this.initTime = java.time.LocalDate.now();
    }

    /**
     * May be initiated with JSON file. Uses {@link FileManager} for collection import.
     *
     * @param filename String of filename
     */
    public CollectionManager(String filename) {
        this();
        this.collection = FileManager.importCollectionFromFile(filename);
    }

    /**
     * Method that just creates a new empty collection
     */
    public void clearCollection() {
        this.collection = new HashMap<String, Dragon>();
    }

    /**
     * Used to return map info
     *
     * @return returns {@link Map}.
     */
    public Map<String, Object> getCollectionInfoMap() {
        Map<String, Object> tmpMap = new HashMap<>();
        tmpMap.put("Type", "HashMap");
        tmpMap.put("Date", this.initTime);
        tmpMap.put("ElementsQuantity", collection.size());
        return tmpMap;
    }

    /**
     * Adds element
     *
     * @param id     String, aka "key" in map
     * @param dragon Dragon object
     * @return returns result of operation. True, if element was added, and false if there is already one in collection.
     */
    public boolean addElement(String id, Dragon dragon) {
        if (collection.containsKey(id)) {
            return false;
        } else {
            collection.put(id, dragon);
            return true;
        }
    }

    public boolean addElement(Map.Entry<String, Dragon> element) {
        return addElement(element.getKey(), element.getValue());
    }

    /**
     * Replaces element
     *
     * @param id     String, aka "key" for Map
     * @param dragon {@link Dragon} object
     */
    public void replaceElement(String id, Dragon dragon) {
        collection.replace(id, dragon);
    }

    /**
     * Some sort of wrapper for remove
     *
     * @param id String, aka "key" for Map
     */
    public void killElement(String id) {
        try {
            collection.remove(id);
        } catch (Throwable e) {
            System.out.println(e);
        }
    }

    /**
     * Small wrapper for Map get() method
     *
     * @param id String key
     * @return returns dragon
     */
    public Dragon getElement(String id) {
        return collection.get(id);
    }

    public boolean hasElement(String id) {
        return collection.containsKey(id);
    }

    public Map<String, Dragon> getCollection() {
        return collection;
    }

    public void setCollection(Map<String, Dragon> collection) {
        this.collection = collection;
    }

    public void sync(){
        Packet packet = RequestConstructor.createRequest();
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        packet = RequestResponseTool.getPacket(channel);
        if(packet == null){
            System.out.println("somehow packet in sync is null");
            return;
        }
        Map<String, Dragon> updatedCollection = packet.getMap();
        this.collection = updatedCollection;

    }

}
// ./app/src/main/java/managers/FileManager.java
package managers;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import structs.classes.Dragon;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Manager for files, Operates with way on how to save something and open it.
 */
public class FileManager {
    /**
     * Method to save collection to file. Uses Jackson.
     *
     * @param filename   name of file where to send
     * @param collection collection which should be stored
     */
    public static void saveCollectionToFile(String filename, Map<String, Dragon> collection) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.registerModule(new JavaTimeModule());
            objectMapper.writeValue(new File(filename), collection);
            System.out.println("JSON создан успешно.");
        } catch (FileNotFoundException e) {
            System.out.println("Такой директории не существует.");
        } catch (IOException e) {
            System.out.println("Произошла неопределённая проблема ввода/вывода.");
        }
    }

    /**
     * Opposite to save. Imports collection from file.
     *
     * @param filename file, from which collection is imported
     * @return returns Map
     */
    public static Map<String, Dragon> importCollectionFromFile(String filename) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            objectMapper.registerModule(new JavaTimeModule());
            Map<String, Dragon> collection = objectMapper.readValue(new File(filename), new TypeReference<Map<String, Dragon>>() {
            });
            System.out.println("JSON импортирован успешно.");
            return collection;
        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден. Создана пустая коллекция (проверьте имя файла).");
        } catch (IOException e) {
            System.out.println("Произошла неопределённая проблема ввода/вывода. Создана пустая коллекция (проверьте файл с изначальной коллекцией).");
        }
        return new HashMap<String, Dragon>();
    }


}
// ./app/src/main/java/managers/DragonCreationManager.java
package managers;

import exceptions.NullForbiddenException;
import exceptions.RangeExceededException;
import structs.classes.*;
import utils.InputChecker;

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Basically class that is used only for dragon creation process
 */
public class DragonCreationManager {
    /**
     * Static method that goes through the whole process of dragon creation.
     *
     * @param input {@link Iterator} that would be used to access all the info about dragon
     * @return returns {@link Dragon} object
     */
    static public Dragon inputDragon(Iterator<String> input) {
        String name = null;
        Double coordinateX = null;
        Long coordinateY = null;
        Integer age = null;
        Color color = null;
        DragonType type = null;
        DragonCharacter character = null;
        Integer caveDepth = null;
        Double treasures = null;
        String tmpInput = "";
        System.out.println("Name:");
        while (name == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                name = InputChecker.inputNonNullChecker(tmpInput);
            } catch (NullForbiddenException e) {
                System.out.println(e);
            }

        }
        System.out.println("Coordinate X (double):");
        while (coordinateX == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                coordinateX = Double.parseDouble(tmpInput);
            } catch (NumberFormatException e) {
                System.out.println("Неправильный формат числа");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        System.out.println("Coordinate Y (Long, must be not null and less than 984):");
        while (coordinateY == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                coordinateY = InputChecker.inputRangeChecker(tmpInput, null, 984.0, true, Long.class);
            } catch (NumberFormatException e) {
                System.out.println("Неправильный формат числа");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        System.out.println("Age (integer, must be more than 0 and not null):");
        while (age == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                age = InputChecker.inputRangeChecker(tmpInput, 0.0, null, true, Integer.class);
            } catch (NumberFormatException e) {
                System.out.println("Неправильный формат числа");
            } catch (RangeExceededException e) {
                System.out.println(e);
            }
        }
        System.out.println("Color (enum, non null, options are: black, yellow, orange, brown):");
        while (color == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                color = InputChecker.getEnum(tmpInput, Color.class);
            } catch (NoSuchElementException e) {
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        System.out.println("Type (enum, non null, options are: water, underground, air, fire):");
        while (type == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                type = InputChecker.getEnum(tmpInput, DragonType.class);
            } catch (NoSuchElementException e) {
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        System.out.println("Character (enum, non null, options are: evil, chaotic_evil, fickle):");
        while (character == null) {
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                character = InputChecker.getEnum(tmpInput, DragonCharacter.class);
            } catch (NoSuchElementException e) {
                System.out.println("Такого элемента нет. Выберите из представленных ранее.");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        System.out.println("Cave is being created. It might be null. \nIf at least one parameter will be null, cave will be null.");
        System.out.println("Cave depth (integer, might be null):");
        try {
            tmpInput = input.next();
        } catch (NoSuchElementException e) {
            System.out.println("Creation process was interrupted, nothing was added");
            return null;
        }
        try {
            if (!tmpInput.trim().isBlank()) {
                caveDepth = Integer.parseInt(tmpInput);
            }
        } catch (NumberFormatException e) {
            System.out.println("Неправильный формат числа, записан null");
        } catch (Exception e) {
            System.out.println(e);
        }
        if (caveDepth != null) {
            System.out.println("Cave depth (double, might be null, at least 0.0):");
            try {
                tmpInput = input.next();
            } catch (NoSuchElementException e) {
                System.out.println("Creation process was interrupted, nothing was added");
                return null;
            }
            try {
                if (!tmpInput.trim().isBlank()) {
                    treasures = InputChecker.inputRangeChecker(tmpInput, 0.0, null, false, Double.class);
                }
            } catch (NumberFormatException e) {
                System.out.println("Неправильный формат числа, записан null");
            } catch (Exception e) {
                System.out.println(e);
            }
        }
        DragonCave dragonCave;
        if (caveDepth == null || treasures == null) {
            dragonCave = null;
        } else {
            dragonCave = new DragonCave(caveDepth, treasures);
        }


        return new Dragon(name,
                new Coordinates(coordinateX, coordinateY),
                age,
                color,
                type,
                character,
                dragonCave);
    }


}
// ./app/src/main/java/Main.java
import commands.local.ExecuteScriptCommand;
import commands.local.ExitCommand;
import commands.local.HelpCommand;
import commands.server.*;
import gui.AppStarter;
import managers.ClientManager;
import managers.CollectionManager;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Iterator;

class Main {
    public static void main(String[] args) {
        CollectionManager collectionManager;
        if (args.length > 0) {
            collectionManager = new CollectionManager(args[0]);
        } else {
            collectionManager = new CollectionManager();
        }
        CommandManager commandManager = new CommandManager(collectionManager);

        commandManager.addLocalCommand(new HelpCommand(commandManager));
        commandManager.addServerCommand(new InfoCommand(collectionManager));
        commandManager.addServerCommand(new ShowCommand(collectionManager));
        commandManager.addServerCommand(new InsertCommand(collectionManager, commandManager));
        commandManager.addServerCommand(new UpdateCommand(collectionManager, commandManager));
        commandManager.addServerCommand(new RemoveKeyCommand(collectionManager));
        commandManager.addServerCommand(new ClearCommand(collectionManager));
        commandManager.addLocalCommand(new ExecuteScriptCommand(commandManager));
        commandManager.addLocalCommand(new ExitCommand());
        commandManager.addServerCommand(new RemoveGreaterCommand(collectionManager));
        commandManager.addServerCommand(new ReplaceIfLowerCommand(collectionManager, commandManager));
        commandManager.addServerCommand(new RemoveGreaterKeyCommand(collectionManager));
        commandManager.addServerCommand(new CountLessThanCharacterCommand(collectionManager));
        commandManager.addServerCommand(new PrintAscendingCommand(collectionManager));
        commandManager.addServerCommand(new PrintFieldDescendingTypeCommand(collectionManager));
        commandManager.addServerCommand(new RegisterCommand(commandManager));
        commandManager.addServerCommand(new LoginCommand(commandManager));

        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        Iterator<String> it = in.lines().iterator();

        ClientManager clientManager = new ClientManager(it, "localhost", 52946, commandManager);

        AppStarter.main(args);

    /*
        "  - help : вывести справку по доступным командам\n" +
        "  - info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)\n" +
        "  - show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении\n" +
        "  - insert null {element} : добавить новый элемент с заданным ключом\n" +
        "  - update id {element} : обновить значение элемента коллекции, id которого равен заданному\n" +
        "  - remove_key null : удалить элемент из коллекции по его ключу\n" +
        "  - clear : очистить коллекцию\n" +
        "  - save : сохранить коллекцию в файл\n" +
        "  - execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.\n" +
        "  - exit : завершить программу (без сохранения в файл)\n" +
        "  - remove_greater {element} : удалить из коллекции все элементы, превышающие заданный\n" +
        "  - replace_if_lowe null {element} : заменить значение по ключу, если новое значение меньше старого\n" +
        "  - remove_greater_key null : удалить из коллекции все элементы, ключ которых превышает заданный\n" +
        "  - count_less_than_character character : вывести количество элементов, значение поля character которых меньше заданного\n" +
        "  - print_ascending : вывести элементы коллекции в порядке возрастания\n" +
        "  - print_field_descending_type : вывести значения поля type всех элементов в порядке убывания";
    */


    }
}
// ./app/src/main/java/gui/AppStarter.java
package gui;

import javafx.application.Application;

public class AppStarter {
    public static void main(String[] args) {
        // Application.launch() is the official way to start a JavaFX application.
        // It sets up the JavaFX toolkit and calls the start() method
        // of the class you provide (LoginScreen in this case).
        Application.launch(DragonTableView.class, args);
    }
}// ./app/src/main/java/gui/DragonTableView.java
package gui;

import java.time.LocalDate;
import java.util.Locale;
import java.util.Map;

import gui.managers.CommandsManager;
import gui.managers.LocaleManager;
import gui.screens.DragonFormScreen;
import gui.screens.LoginScreen;
import javafx.application.Application;
import javafx.beans.binding.Bindings;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.Stage;
import managers.CollectionManager;
import structs.User;
import structs.classes.Color;
import structs.classes.Coordinates;
import structs.classes.Dragon;
import structs.classes.DragonCave;
import structs.classes.DragonCharacter;
import structs.classes.DragonType;
import structs.wrappers.DragonDisplayWrapper;


public class DragonTableView extends Application {
    private final LocaleManager localeManager = LocaleManager.getInstance();
    private static CollectionManager collectionManager;
    private final ObservableList<DragonDisplayWrapper> masterData = FXCollections.observableArrayList();
    User user = null;


    Label userLabel;
    private final static int POLL_RATIO = 1000;

    private TableView<DragonDisplayWrapper> table = new TableView<>();
    private TextField filterField;
    private Pane visual;
    private CommandsManager commandsManager = new CommandsManager();

    public static void initialize(CollectionManager cm) {
        collectionManager = cm;
    }

    @Override
    public void start(Stage primaryStage) {
        startLogin();
        primaryStage.titleProperty().bind(localeManager.createStringBinding("app.title"));


        if (collectionManager == null) {
            collectionManager = new CollectionManager();
            Dragon testDragon1 = new Dragon("Smaug", new Coordinates(10.5, 100L), 171, Color.BLACK, DragonType.FIRE, DragonCharacter.EVIL, new DragonCave(1000, 100000.0));
            testDragon1.setOwnerLogin("user1");
            Dragon testDragon2 = new Dragon("Viserion", new Coordinates(25.0, 500L), 5, Color.YELLOW, DragonType.AIR, DragonCharacter.FICKLE, null);
            testDragon2.setOwnerLogin("user2");
            collectionManager.addElement("smaug_key", testDragon1);
            collectionManager.addElement("viserion_key", testDragon2);
        }

        BorderPane root = new BorderPane();
        root.setPadding(new Insets(10));

        BorderPane topPanel = createTopPanel();
        root.setTop(topPanel);

        setupTable();
        root.setCenter(table);

        FlowPane bottomPanel = createBottomPanel();
        root.setBottom(bottomPanel);

        visual = createRightPannel(primaryStage); 
        visual.prefWidthProperty().bind(root.widthProperty().multiply(0.475));
        visual.prefHeightProperty().bind(root.heightProperty());
        visual.setStyle(
            "-fx-border-color: #333333;" +
            "-fx-border-width: 2;" +
            "-fx-border-radius: 4;" +
            "-fx-background-color: white;"
        );


        Label title = new Label("Область визуализации");
        title.setFont(Font.font("Arial", FontWeight.NORMAL, 14));

        VBox rightBox = new VBox(5);

        rightBox.setAlignment(Pos.TOP_CENTER);
        rightBox.getChildren().addAll(title, visual);
        BorderPane.setMargin(rightBox, new Insets(0, 0, 0, 10)); 

        root.setRight(rightBox);

        table.requestFocus();
        table.getSelectionModel().select(0);
        table.getFocusModel().focus(0);
        loadDataFromCollectionManager();

        Scene scene = new Scene(root, 1200, 800);
        primaryStage.setScene(scene);

        new Thread(() -> {
            while (true) {
                try {
                    //DragonDisplayWrapper dragonDisplayWrapper = table.getSelectionModel().getSelectedItem();
                    if(table.getSelectionModel().getSelectedItem()!=null){
                        Thread.sleep(200);
                    }else{
                        collectionManager.sync();

                        Platform.runLater(() -> {
                            loadDataFromCollectionManager();
                            updateVisualPane(primaryStage);
                        });
                        /*if(dragonDisplayWrapper != null){
                            System.out.println(table.getSelectionModel().getSelectedIndex());
                            System.out.println(table.getSelectionModel().getFocusedIndex());

                            table.getSelectionModel().select(dragonDisplayWrapper);

                        }*/
                        Thread.sleep(1000);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
        localeManager.localeProperty().addListener((obs, oldVal, newVal) -> table.refresh());
        primaryStage.show();
    }

    private void startLogin() {
        this.user = (new LoginScreen()).start();
    }

    private void updateVisualPane(Stage primaryStage) {
        visual.getChildren().clear();  
        for (DragonDisplayWrapper dragonWrapper : masterData) {
            Dragon dragon = dragonWrapper.getOriginalDragon();
            Node visualisation = getVisualisation(dragon, primaryStage, dragonWrapper.getKey());
            visual.getChildren().add(visualisation);
        }
    }

    private void updateDragon(Dragon dragon, String key){

        DragonDisplayWrapper selectedForUpdate = new DragonDisplayWrapper(key, dragon);
        if (dragon.getOwnerLogin().equals(user.getLogin())) {
            DragonFormScreen updateDialog = new DragonFormScreen();
            Dragon newDragon = updateDialog.updateDragon(selectedForUpdate);

            if (newDragon != null) {
                newDragon.setOwnerLogin(user.getLogin());
                collectionManager.replaceElement(selectedForUpdate.getKey(), newDragon);
                String response = commandsManager.updateDragon(new DragonDisplayWrapper(selectedForUpdate.getKey(), newDragon), user);
                showAlert(Alert.AlertType.INFORMATION, "Execution result", response);
                collectionManager.sync();
                loadDataFromCollectionManager();
            }
        
        } else {
            showAlert(Alert.AlertType.ERROR, "Bruh", "Sorry, but you can not modify someones dragon");
        }
    }
    private BorderPane createTopPanel() {
        BorderPane topPanel = new BorderPane();

        HBox filterPanel = new HBox(10);
        filterPanel.setPadding(new Insets(10));
        filterPanel.setAlignment(Pos.CENTER_RIGHT);
        Label filterLabel = new Label();
        filterLabel.textProperty().bind(localeManager.createStringBinding("filter.label"));
        filterField = new TextField();
        filterField.promptTextProperty().bind(localeManager.createStringBinding("filter.prompt"));

        Button refreshButton = new Button();
        refreshButton.textProperty().bind(localeManager.createStringBinding("button.refresh"));
        refreshButton.setOnAction(e -> loadDataFromCollectionManager());

        ComboBox<Locale> languageSelector = createLanguageSelector();


        filterPanel.getChildren().addAll(filterLabel, filterField, refreshButton, languageSelector);


        HBox userPanel = new HBox(10);
        userPanel.setPadding(new Insets(10));
        userPanel.setAlignment(Pos.CENTER_LEFT);
        Label userLabel = new Label();
        userLabel.setText((user == null) ? "" : user.getLogin());


        Button registerButton = new Button();
        registerButton.textProperty().bind(localeManager.createStringBinding("button.registerLogin"));


        userPanel.getChildren().addAll(userLabel, registerButton);
        registerButton.setOnAction(e -> {
            startLogin();
            userLabel.setText((user == null) ? "" : user.getLogin());
        });

        topPanel.setLeft(userPanel);
        topPanel.setRight(filterPanel);
        return topPanel;
    }

    private ComboBox<Locale> createLanguageSelector() {
        ComboBox<Locale> languageSelector = new ComboBox<>();

        languageSelector.getItems().add(new Locale("ru", "RU"));
        languageSelector.getItems().add(new Locale("pl", "PL"));
        languageSelector.getItems().add(new Locale("is", "IS"));
        languageSelector.getItems().add(new Locale("en", "IN"));

        languageSelector.setConverter(new javafx.util.StringConverter<Locale>() {
            @Override
            public String toString(Locale locale) {
                if (locale == null) return "";
                return locale.getDisplayLanguage(locale);
            }
            @Override
            public Locale fromString(String string) {
                return null;
            }
        });

        languageSelector.setValue(localeManager.getLocale());

        languageSelector.valueProperty().addListener((obs, oldLocale, newLocale) -> {
            if (newLocale != null) {
                localeManager.setLocale(newLocale);
            }
        });

        return languageSelector;
    }

    private Pane createRightPannel(Stage primaryStage){
        Pane pane = new Pane();
        for (DragonDisplayWrapper dragonWrapper : masterData) {
            Dragon dragon = dragonWrapper.getOriginalDragon();
            Node visualisation = getVisualisation(dragon, primaryStage, dragonWrapper.getKey());
            pane.getChildren().add(visualisation);
        }
        return pane;
    }


    private Node getVisualisation(Dragon dragon, Stage primaryStage, String key){
        DragonType type = dragon.getType();
        String ownersLogin = dragon.getOwnerLogin();
        javafx.scene.paint.Color color = getColorByOwner(ownersLogin);
        double x = dragon.getCoordinates().getX();
        double y = dragon.getCoordinates().getY();
        double correctX = ((101*x) % 500) + 50;
        double correctY = (y*423 % 600);
        switch(type){
            case FIRE -> {
            Circle figure = new Circle(correctX, correctY, 15);
            figure.setFill(color);
            attachInfoHandler(figure, dragon, primaryStage, key);
            return figure;
        }
        case AIR -> {
            Polygon figure = new Polygon();
            figure.getPoints().addAll(
                correctX, correctY - 20,
                correctX - 15, correctY + 15,
                correctX + 15, correctY + 15
            );
            figure.setFill(color);
            attachInfoHandler(figure, dragon, primaryStage, key);
            return figure;
        }
        case WATER -> {
            Polygon figure = new Polygon();
            figure.getPoints().addAll(
                correctX, correctY - 20,
                correctX - 15, correctY,
                correctX, correctY + 20,
                correctX + 15, correctY
            );
            figure.setFill(color);
            attachInfoHandler(figure, dragon, primaryStage, key);
            return figure;

        }
        case UNDERGROUND -> {
            Rectangle figure = new Rectangle(correctX - 15, correctY - 15, 30, 30);
            figure.setFill(color);
            attachInfoHandler(figure, dragon, primaryStage, key);
            return figure;
        }default ->{
            Circle figure = new Circle();
            figure.setFill(color);
            attachInfoHandler(figure, dragon, primaryStage, key);
            return figure;
        }
        }


    }

    private javafx.scene.paint.Color getColorByOwner(String login){
        int hash = Math.abs(login.hashCode());
        double hue = (hash*788) % 360;
        double saturation = 0.7;
        double brightness = 0.9;
        return javafx.scene.paint.Color.hsb(hue, saturation, brightness);
    }

private void attachInfoHandler(Node node, Dragon dragon, Stage primaryStage, String key) {
    node.setOnMouseClicked(event -> {
        Stage dialog = new Stage();
        dialog.initOwner(primaryStage);
        dialog.setTitle("Информация о драконе");

        VBox vbox = new VBox(10);
        vbox.setPadding(new Insets(15));

        Label header = new Label(dragon.getName() + " (" + dragon.getOwnerLogin() + ")");
        header.setStyle("-fx-font-weight: bold; -fx-font-size: 16px;");

        StringBuilder content = new StringBuilder();
        content.append("Имя: ").append(dragon.getName()).append("\n")
               .append("Координаты: (")
               .append(dragon.getCoordinates().getX()).append(", ")
               .append(dragon.getCoordinates().getY()).append(")\n")
               .append("Возраст: ").append(dragon.getAge()).append("\n")
               .append("Тип: ").append(dragon.getType()).append("\n")
               .append("Характер: ").append(dragon.getCharacter());
        if (dragon.getCave() != null) {
            content.append("\nПещера: ")
                   .append(dragon.getCave().getNumberOfTreasures())
                   .append(" сокровищ");
        }

        TextArea infoArea = new TextArea(content.toString());
        infoArea.setEditable(false);
        infoArea.setWrapText(true);

        Button updateButton = new Button("Обновить");
        updateButton.setOnAction(e -> {
            updateDragon(dragon, key);
            dialog.close();
        });

        Button closeButton = new Button("Закрыть");
        closeButton.setOnAction(e -> dialog.close());

        HBox buttons = new HBox(10, updateButton, closeButton);
        buttons.setAlignment(Pos.CENTER_RIGHT);

        vbox.getChildren().addAll(header, infoArea, buttons);

        Scene scene = new Scene(vbox);
        dialog.setScene(scene);
        dialog.showAndWait();
    });
}
    private void setupTable() {
        TableColumn<DragonDisplayWrapper, String> keyCol = new TableColumn<>();
        keyCol.textProperty().bind(localeManager.createStringBinding("column.key"));
        keyCol.setCellValueFactory(new PropertyValueFactory<>("key"));

        TableColumn<DragonDisplayWrapper, String> ownerCol = new TableColumn<>();
        ownerCol.textProperty().bind(localeManager.createStringBinding("column.owner"));
        ownerCol.setCellValueFactory(new PropertyValueFactory<>("owner"));

        TableColumn<DragonDisplayWrapper, String> nameCol = new TableColumn<>();
        nameCol.textProperty().bind(localeManager.createStringBinding("column.name"));
        nameCol.setCellValueFactory(new PropertyValueFactory<>("name"));

        TableColumn<DragonDisplayWrapper, Double> xCol = new TableColumn<>("X");
        xCol.setCellValueFactory(new PropertyValueFactory<>("x"));
        xCol.setCellFactory(
                column -> new TableCell<DragonDisplayWrapper, Double>(){
            @Override
            protected void updateItem(Double item, boolean empty){
                super.updateItem(item, empty);
                if(empty || item == null){
                    setText(null);
                } else {
                    setText(localeManager.formatNumber(item));
                }
            }
        });

        TableColumn<DragonDisplayWrapper, Long> yCol = new TableColumn<>("Y");
        yCol.setCellValueFactory(new PropertyValueFactory<>("y"));

        TableColumn<DragonDisplayWrapper, LocalDate> dateCol = new TableColumn<>();
        dateCol.textProperty().bind(localeManager.createStringBinding("column.creationDate"));
        dateCol.setCellValueFactory(new PropertyValueFactory<>("creationDate"));
        dateCol.setCellFactory(
                column -> new TableCell<DragonDisplayWrapper, LocalDate>(){
                    @Override
                    protected void updateItem(LocalDate item, boolean empty){
                        super.updateItem(item, empty);
                        if(empty || item == null){
                            setText(null);
                        } else {
                            setText(localeManager.formatDate(item));
                        }
                    }
                });

        TableColumn<DragonDisplayWrapper, Integer> ageCol = new TableColumn<>();
        ageCol.textProperty().bind(localeManager.createStringBinding("column.age"));
        ageCol.setCellValueFactory(new PropertyValueFactory<>("age"));

        TableColumn<DragonDisplayWrapper, String> colorCol = new TableColumn<>();
        colorCol.textProperty().bind(localeManager.createStringBinding("column.color"));
        colorCol.setCellValueFactory(new PropertyValueFactory<>("color"));

        TableColumn<DragonDisplayWrapper, String> typeCol = new TableColumn<>();
        typeCol.textProperty().bind(localeManager.createStringBinding("column.type"));
        typeCol.setCellValueFactory(new PropertyValueFactory<>("type"));

        TableColumn<DragonDisplayWrapper, String> charCol = new TableColumn<>();
        charCol.textProperty().bind(localeManager.createStringBinding("column.character"));
        charCol.setCellValueFactory(new PropertyValueFactory<>("character"));

        TableColumn<DragonDisplayWrapper, Integer> depthCol = new TableColumn<>();
        depthCol.textProperty().bind(localeManager.createStringBinding("column.depth"));
        depthCol.setCellValueFactory(new PropertyValueFactory<>("depth"));

        TableColumn<DragonDisplayWrapper, Double> treasuresCol = new TableColumn<>();
        treasuresCol.textProperty().bind(localeManager.createStringBinding("column.treasures"));
        treasuresCol.setCellValueFactory(new PropertyValueFactory<>("treasures"));
        treasuresCol.setCellFactory(
                column -> new TableCell<DragonDisplayWrapper, Double>(){
                    @Override
                    protected void updateItem(Double item, boolean empty){
                        super.updateItem(item, empty);
                        if(empty || item == null){
                            setText(null);
                        } else {
                            setText(localeManager.formatNumber(item));
                        }
                    }
                });

        table.getColumns().addAll(keyCol, ownerCol, nameCol, xCol, yCol, dateCol, ageCol, colorCol, typeCol, charCol, depthCol, treasuresCol);

        FilteredList<DragonDisplayWrapper> filteredData = new FilteredList<>(masterData, p -> true);

        filterField.textProperty().addListener((observable, oldValue, newValue) -> {
            filteredData.setPredicate(dragonWrapper -> {
                if (newValue == null || newValue.isEmpty()) {
                    return true;
                }
                String lowerCaseFilter = newValue.toLowerCase();

                return dragonWrapper.getStreamOfFields()
                        .anyMatch(field -> field.toLowerCase().contains(lowerCaseFilter));
            });
        });


        SortedList<DragonDisplayWrapper> sortedData = new SortedList<>(filteredData);
        sortedData.comparatorProperty().bind(table.comparatorProperty());

        table.setItems(sortedData);
        table.getSelectionModel().setSelectionMode(SelectionMode.SINGLE);
    }

    private FlowPane createBottomPanel() {
        FlowPane bottomPanel = new FlowPane();
        bottomPanel.setPadding(new Insets(10, 10, 10, 120));
        bottomPanel.setHgap(10);
        bottomPanel.setVgap(10);
        bottomPanel.setAlignment(Pos.CENTER_LEFT);

        String[] commandNames = {"info", "show", "insert", "update", "remove_key", "remove_greater", "replace_if_lower"};

        for (String commandName : commandNames) {
            Button btn = new Button();
            btn.textProperty().bind(localeManager.createStringBinding("command."+commandName));
            btn.setOnAction(e -> handleCommand(commandName));
            bottomPanel.getChildren().add(btn);
        }
        return bottomPanel;
    }


    private void handleCommand(String commandName) {

        //System.out.println("Executing command: " + commandName);

        switch (commandName) {

            case "insert":
                DragonFormScreen insertDialog = new DragonFormScreen();
                DragonDisplayWrapper newEntry = insertDialog.getNewDragon();
                if (newEntry != null) {
                    newEntry.getValue().setOwnerLogin(user.getLogin());
                    String response = commandsManager.insertDragon(newEntry, user);
                    showAlert(Alert.AlertType.INFORMATION, "alert.result.title", response);
                    collectionManager.sync();
                    loadDataFromCollectionManager();
                }
                break;

            case "update":
                DragonDisplayWrapper selectedForUpdate = table.getSelectionModel().getSelectedItem();
                if(selectedForUpdate != null){
                    if (selectedForUpdate.getOwner().equals(user.getLogin())) {
                        DragonFormScreen updateDialog = new DragonFormScreen();
                        Dragon newDragon = updateDialog.updateDragon(selectedForUpdate);
                        newDragon.setOwnerLogin(user.getLogin());
                        if (newDragon != null) {
                            collectionManager.replaceElement(selectedForUpdate.getKey(), newDragon);
                            String response = commandsManager.updateDragon(new DragonDisplayWrapper(selectedForUpdate.getKey(), newDragon), user);
                            showAlert(Alert.AlertType.INFORMATION, "alert.result.title", response);
                            collectionManager.sync();
                            loadDataFromCollectionManager();
                        }
                    } else {
                        showAlert(Alert.AlertType.ERROR, "alert.error.title", localeManager.getString("alert.error.notOwner"));
                    }

                }
                break;

            case "replace_if_lower":
                DragonDisplayWrapper selectedForReplace = table.getSelectionModel().getSelectedItem();
                if(selectedForReplace != null){
                    if (selectedForReplace.getOwner().equals(user.getLogin())) {
                        DragonFormScreen updateDialog = new DragonFormScreen();
                        Dragon newDragon = updateDialog.updateDragon(selectedForReplace);
                        newDragon.setOwnerLogin(user.getLogin());
                        if (newDragon != null) {
                            collectionManager.replaceElement(selectedForReplace.getKey(), newDragon);
                            String response = commandsManager.replaceIfLowerDragon(new DragonDisplayWrapper(selectedForReplace.getKey(), newDragon), user);
                            showAlert(Alert.AlertType.INFORMATION, "alert.result.title", response);
                            collectionManager.sync();
                            loadDataFromCollectionManager();
                        }
                    } else {
                        showAlert(Alert.AlertType.ERROR, "alert.error.title", localeManager.getString("alert.error.notOwner"));
                    }

                }
                break;

            case "remove_key":
                DragonDisplayWrapper selectedForRemove = table.getSelectionModel().getSelectedItem();
                if(selectedForRemove != null){
                    if (selectedForRemove.getOwner().equals(user.getLogin())) {
                        String response = commandsManager.removeKeyDragon(new String[]{selectedForRemove.getKey()}, user);
                        showAlert(Alert.AlertType.INFORMATION, "alert.result.title", response);
                        collectionManager.sync();
                        loadDataFromCollectionManager();

                    } else {
                        showAlert(Alert.AlertType.ERROR, "alert.error.title", localeManager.getString("alert.error.notOwner"));
                    }

                }
                break;

            case "remove_greater":
                if (user == null){
                    showAlert(Alert.AlertType.WARNING, "alert.warning.title", localeManager.getString("alert.warning.notLoggedIn"));
                    break;
                }
                DragonDisplayWrapper selectedForRemoveGr = table.getSelectionModel().getSelectedItem();
                if(selectedForRemoveGr != null){
                    if (selectedForRemoveGr.getOwner().equals(user.getLogin())) {
                        String response = commandsManager.removeKeyGrDragon(new String[]{selectedForRemoveGr.getKey()}, user);
                        showAlert(Alert.AlertType.INFORMATION, "alert.result.title", response);
                        collectionManager.sync();
                        loadDataFromCollectionManager();

                    } else {
                        showAlert(Alert.AlertType.ERROR, "alert.error.title", localeManager.getString("alert.error.notOwner"));
                    }

                }
                break;

            case "info":
                collectionManager.sync();
                loadDataFromCollectionManager();
                Map<String, Object> info = collectionManager.getCollectionInfoMap();
                showAlert(Alert.AlertType.INFORMATION, "alert.info.title",
                        String.format(localeManager.getString("alert.info.content"),
                                info.get("Type"), info.get("Date"), info.get("ElementsQuantity")));
                break;

            case "show":
            default:
                System.out.println("Displaying current collection state.");
                collectionManager.sync();
                loadDataFromCollectionManager();
                break;
        }
    }

    private void loadDataFromCollectionManager() {
        masterData.clear();
        Map<String, Dragon> collection = collectionManager.getCollection();
        for (Map.Entry<String, Dragon> entry : collection.entrySet()) {
            masterData.add(new DragonDisplayWrapper(entry.getKey(), entry.getValue()));
        }
        table.sort();
    }

    private void showAlert(Alert.AlertType alertType, String title, String message) {
        Alert alert = new Alert(alertType);
        alert.titleProperty().bind(localeManager.createStringBinding(title));
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }


    /**
     * Вспомогательный класс-обертка для удобного отображения в TableView.
     * Он "уплощает" объект Dragon, делая его поля доступными через простые геттеры.
     */

}

// ./app/src/main/java/gui/managers/ActionsManager.java
package gui.managers;

import java.io.IOException;
import java.nio.channels.SocketChannel;

import commands.server.InfoCommand;
import managers.ConnectionManager;
import structs.Packet;
import utils.RequestConstructor;
import utils.RequestResponseTool;

public class ActionsManager {

    static int MAX_RECONNECT_ATTEMPTS = 5;
    static int RECONNECT_TIMEOUT = 2000; //millis
    String hostname = "188.242.233.237";
    int port = 52947;
    SocketChannel channel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT);


    public String getInfo() {
        Packet packet = RequestConstructor.createRequest(new InfoCommand(null), null, null, null);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return "Error Connecting to the server";
        }
        packet = RequestResponseTool.getPacket(channel);
        return packet.getText();
    }
}
// ./app/src/main/java/gui/managers/AuthManager.java
package gui.managers;

import java.io.IOException;
import java.nio.channels.SocketChannel;

import commands.server.LoginCommand;
import commands.server.RegisterCommand;
import managers.ConnectionManager;
import structs.Packet;
import structs.User;
import utils.RequestConstructor;
import utils.RequestResponseTool;

public class AuthManager {

    static int MAX_RECONNECT_ATTEMPTS = 5;
    static int RECONNECT_TIMEOUT = 2000; //millis
    String hostname = "188.242.233.237";
    int port = 52947;
    SocketChannel channel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT);

    public AuthManager() {
    }


    public AuthManager(String hostname, int port) {
        this.hostname = hostname;
        this.port = port;
    }

    public boolean login(String login, String password) {
        if(login == null){
            return false;
        }
        if (login.trim().isBlank()) {
            return false;
        }
        if(password == null){
            return false;
        }
        if (password.trim().isBlank()) {
            return false;
        }
        Packet packet = RequestConstructor.createRequest(new LoginCommand(null), null, new User(login, password), null);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return false;
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            if (packet.getText().equals("no such user") || packet.getText().equals("wrong password")) {
                return false;
            }
            return true;
        } else {
            return false;
        }
    }

    public boolean register(String login, String password) {
        if(login == null){
            return false;
        }
        if (login.trim().isBlank()) {
            return false;
        }
        if(password == null){
            return false;
        }
        if (password.trim().isBlank()) {
            return false;
        }
        SocketChannel channel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT);
        Packet packet = RequestConstructor.createRequest(new RegisterCommand(null), null, new User(login, password), null);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return false;
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            if (packet.getText().equals("User registered successfully")) {
                return true;
            }
            return false;
        } else {
            return false;
        }
    }

}
// ./app/src/main/java/gui/managers/CommandsManager.java
package gui.managers;

import java.io.IOException;
import java.nio.channels.SocketChannel;

import commands.server.InsertCommand;
import commands.server.RemoveGreaterKeyCommand;
import commands.server.RemoveKeyCommand;
import commands.server.ReplaceIfLowerCommand;
import commands.server.UpdateCommand;
import managers.ConnectionManager;
import structs.Packet;
import structs.User;
import structs.wrappers.DragonDisplayWrapper;
import utils.RequestConstructor;
import utils.RequestResponseTool;

public class CommandsManager {

    static int MAX_RECONNECT_ATTEMPTS = 5;
    static int RECONNECT_TIMEOUT = 2000; //millis
    String hostname = "188.242.233.237";
    int port = 52947;
    SocketChannel channel = ConnectionManager.connectToServer(hostname, port, MAX_RECONNECT_ATTEMPTS, RECONNECT_TIMEOUT);

    public CommandsManager() {
    }


    public CommandsManager(String hostname, int port) {
        this.hostname = hostname;
        this.port = port;
    }

    public String insertDragon(DragonDisplayWrapper dragonEntry, User user) {
        Packet packet = RequestConstructor.createRequest(new InsertCommand(null, null), null, dragonEntry, user);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return "Some troubles";
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            return packet.getText();
        } else {
            return "Response is not text";
        }
    }

    public String updateDragon(DragonDisplayWrapper dragonEntry, User user) {
        Packet packet = RequestConstructor.createRequest(new UpdateCommand(null, null), null, dragonEntry, user);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return "Some troubles";
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            return packet.getText();
        } else {
            return "Response is not text";
        }
    }

    public String replaceIfLowerDragon(DragonDisplayWrapper dragonEntry, User user) {
        Packet packet = RequestConstructor.createRequest(new ReplaceIfLowerCommand(null, null), null, dragonEntry, user);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return "Some troubles";
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            return packet.getText();
        } else {
            return "Response is not text";
        }
    }

    public String removeKeyDragon(String[] args, User user) {
        Packet packet = RequestConstructor.createRequest(new RemoveKeyCommand(null), args, null, user);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return "Some troubles";
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            return packet.getText();
        } else {
            return "Response is not text";
        }
    }

    public String removeKeyGrDragon(String[] args, User user) {
        Packet packet = RequestConstructor.createRequest(new RemoveGreaterKeyCommand(null), args, null, user);
        try {
            RequestResponseTool.sendPacket(channel, packet);
        } catch (IOException ex) {
            return "Some troubles";
        }
        packet = RequestResponseTool.getPacket(channel);
        if (packet.isText()) {
            return packet.getText();
        } else {
            return "Response is not text";
        }
    }
}
// ./app/src/main/java/gui/managers/LocaleManager.java
package gui.managers;

import java.text.NumberFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.Locale;
import java.util.ResourceBundle;

import javafx.beans.binding.Bindings;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;

public class LocaleManager {
    private static final LocaleManager INSTANCE = new LocaleManager();
    private static final String BUNDLE_PATH = "gui.i18n.messages";

    private final ObjectProperty<Locale> locale;
    private ObjectProperty<ResourceBundle> resources = new SimpleObjectProperty<>();

    private LocaleManager() {
        locale = new SimpleObjectProperty<>(new Locale("ru", "RU"));
        locale.addListener((observable, oldValue, newValue) -> loadResources(newValue));
        loadResources(locale.get());
    }

    public static LocaleManager getInstance() {
        return INSTANCE;
    }

    private void loadResources(Locale locale) {
        try {
            resources.set(ResourceBundle.getBundle(BUNDLE_PATH, locale));
        } catch (Exception e) {
            resources.set(ResourceBundle.getBundle(BUNDLE_PATH, Locale.ROOT));
            System.err.println("Could not find resource bundle for locale " + locale + ", using default.");
        }
    }

    public Locale getLocale() {
        return locale.get();
    }

    public void setLocale(Locale locale) {
        this.locale.set(locale);
    }

    public ObjectProperty<Locale> localeProperty() {
        return locale;
    }

    public String getString(String key) {
        return resources.get().getString(key);
    }

    public StringBinding createStringBinding(String key) {
        return Bindings.createStringBinding(() -> getString(key), resources);
    }

    public String formatDate(LocalDate date) {
        if (date == null) return "";
        DateTimeFormatter dtf = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).withLocale(getLocale());
        return dtf.format(date);
    }

    public String formatNumber(Number number) {
        if (number == null) return "";
        NumberFormat nf = NumberFormat.getNumberInstance(getLocale());
        return nf.format(number);
    }
}// ./app/src/main/java/gui/screens/InfoScreen.java
package gui.screens;

import gui.managers.ActionsManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.GridPane;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class InfoScreen {
    public void start() {
        Stage primaryStage = new Stage();
        primaryStage.setTitle("Dragon Collection Manager - Login");
        GridPane grid = new GridPane();
        grid.setAlignment(Pos.CENTER);
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new Insets(25, 25, 25, 25));


        Text scenetitle = new Text((new ActionsManager()).getInfo());
        scenetitle.setFont(Font.font("Tahoma", FontWeight.NORMAL, 20));
        grid.add(scenetitle, 0, 0, 2, 1);

        Button okButton = new Button("Ok");

        grid.add(okButton, 1, 4);

        okButton.setOnAction(e -> {
            primaryStage.close();
        });

        Scene scene = new Scene(grid, 400, 300);
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.show();

    }
}
// ./app/src/main/java/gui/screens/LoginScreen.java
package gui.screens;

import gui.managers.AuthManager;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import structs.User;

public class LoginScreen {
    User returnableUser = null;

    public User start() {
        Stage primaryStage = new Stage();
        primaryStage.setTitle("Dragon Collection Manager - Login");


        GridPane grid = new GridPane();
        grid.setAlignment(Pos.CENTER);
        grid.setHgap(10);
        grid.setVgap(10);
        grid.setPadding(new Insets(25, 25, 25, 25));


        Text scenetitle = new Text("Welcome");
        scenetitle.setFont(Font.font("Tahoma", FontWeight.NORMAL, 20));
        grid.add(scenetitle, 0, 0, 2, 1);


        Label userName = new Label("Username:");
        grid.add(userName, 0, 1);

        TextField userTextField = new TextField();
        grid.add(userTextField, 1, 1);

        Label pw = new Label("Password:");
        grid.add(pw, 0, 2);

        PasswordField pwBox = new PasswordField();
        grid.add(pwBox, 1, 2);

        // Add Login and Register buttons
        Button loginBtn = new Button("Log in");
        Button registerBtn = new Button("Register");
        HBox hbBtn = new HBox(10); // A horizontal box to hold the buttons
        hbBtn.setAlignment(Pos.BOTTOM_RIGHT);
        hbBtn.getChildren().addAll(registerBtn, loginBtn);
        grid.add(hbBtn, 1, 4);

        // Add a text field to display action results (e.g., "Login failed")
        final Text actiontarget = new Text();
        grid.add(actiontarget, 0, 6, 2, 1);

        // --- Event Handlers for Buttons ---

        loginBtn.setOnAction(e -> {
            String username = userTextField.getText();
            String password = pwBox.getText();
            System.out.println("Attempting login for user: " + username);

            boolean success = (new AuthManager()).login(username, password);
            if (success) {
                actiontarget.setFill(Color.GREEN);
                actiontarget.setText("Login successful!");
                this.returnableUser = new User(username, password);
                primaryStage.close();
            } else {
                actiontarget.setFill(Color.FIREBRICK);
                actiontarget.setText("Login failed. Please try again.");
            }
        });

        registerBtn.setOnAction(e -> {
            String username = userTextField.getText();
            String password = pwBox.getText();


            System.out.println("Attempting to register user: " + username);
            boolean success = (new AuthManager()).register(username, password);
            if (success) {
                actiontarget.setFill(Color.GREEN);
                actiontarget.setText("Registration successful!");
                this.returnableUser = new User(username, password);
                primaryStage.close();
            } else {
                actiontarget.setFill(Color.FIREBRICK);
                actiontarget.setText("Registration failed. Please try again.");
            }
        });


        // Create the scene and set it on the stage
        Scene scene = new Scene(grid, 400, 300);
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.showAndWait();

        // Show the window
        return returnableUser;
    }
}// ./app/src/main/java/gui/screens/DragonFormScreen.java
package gui.screens;

import structs.wrappers.DragonDisplayWrapper;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Modality;
import javafx.stage.Stage;
import structs.classes.*;

import java.util.Map;

public class DragonFormScreen {

    private Dragon resultDragon = null;
    private DragonDisplayWrapper resultEntry = null;

    public DragonDisplayWrapper getNewDragon() {
        this.resultEntry = null;
        showEntryForm("Create New Dragon");
        return this.resultEntry;
    }

    public Dragon updateDragon(DragonDisplayWrapper dragonWrapper) {
        this.resultDragon = null;
        showDragonForm("Update Dragon: " + dragonWrapper.getKey(), dragonWrapper.getOriginalDragon());
        return this.resultDragon;
    }

    private void showDragonForm(String title, Dragon existingDragon) {
        Stage dialogStage = new Stage();
        dialogStage.initModality(Modality.APPLICATION_MODAL);
        dialogStage.setTitle(title);

        GridPane grid = new GridPane();
        grid.setPadding(new Insets(20));
        grid.setHgap(10);
        grid.setVgap(10);

        TextField nameField = new TextField();
        TextField xField = new TextField();
        TextField yField = new TextField();
        TextField ageField = new TextField();
        ComboBox<Color> colorBox = new ComboBox<>();
        colorBox.getItems().setAll(Color.values());
        ComboBox<DragonType> typeBox = new ComboBox<>();
        typeBox.getItems().setAll(DragonType.values());
        ComboBox<DragonCharacter> characterBox = new ComboBox<>();
        characterBox.getItems().setAll(DragonCharacter.values());
        characterBox.setPromptText("Select a character (optional)");

        CheckBox hasCaveCheck = new CheckBox();
        TextField depthField = new TextField();
        TextField treasuresField = new TextField();

        depthField.disableProperty().bind(hasCaveCheck.selectedProperty().not());
        treasuresField.disableProperty().bind(hasCaveCheck.selectedProperty().not());

        grid.add(new Label("Name:"), 0, 0);
        grid.add(nameField, 1, 0);
        grid.add(new Label("Coordinate X:"), 0, 1);
        grid.add(xField, 1, 1);
        grid.add(new Label("Coordinate Y:"), 0, 2);
        grid.add(yField, 1, 2);
        grid.add(new Label("Age:"), 0, 3);
        grid.add(ageField, 1, 3);
        grid.add(new Label("Color:"), 0, 4);
        grid.add(colorBox, 1, 4);
        grid.add(new Label("Type:"), 0, 5);
        grid.add(typeBox, 1, 5);
        grid.add(new Label("Character:"), 0, 6);
        grid.add(characterBox, 1, 6);
        grid.add(new Label("Has Cave:"), 0, 7);
        grid.add(hasCaveCheck, 1, 7);
        grid.add(new Label("Cave Depth:"), 0, 8);
        grid.add(depthField, 1, 8);
        grid.add(new Label("Cave Treasures:"), 0, 9);
        grid.add(treasuresField, 1, 9);

        if (existingDragon != null) {
            nameField.setText(existingDragon.getName());
            xField.setText(String.valueOf(existingDragon.getCoordinates().getX()));
            yField.setText(String.valueOf(existingDragon.getCoordinates().getY()));
            ageField.setText(String.valueOf(existingDragon.getAge()));
            colorBox.setValue(existingDragon.getColor());
            typeBox.setValue(existingDragon.getType());
            characterBox.setValue(existingDragon.getCharacter());

            if (existingDragon.getCave() != null) {
                hasCaveCheck.setSelected(true);
                depthField.setText(String.valueOf(existingDragon.getCave().getDepth()));
                treasuresField.setText(String.valueOf(existingDragon.getCave().getNumberOfTreasures()));
            }
        } else {
            colorBox.getSelectionModel().selectFirst();
            typeBox.getSelectionModel().selectFirst();
        }

        Button okButton = new Button("OK");
        Button cancelButton = new Button("Cancel");

        okButton.setOnAction(e -> {
            if (validateAndCreateDragon(nameField, xField, yField, ageField, colorBox, typeBox, characterBox, hasCaveCheck, depthField, treasuresField)) {
                dialogStage.close();
            }
        });

        cancelButton.setOnAction(e -> dialogStage.close());

        HBox buttonBox = new HBox(10, cancelButton, okButton);
        buttonBox.setAlignment(Pos.CENTER_RIGHT);
        grid.add(buttonBox, 1, 10);

        Scene scene = new Scene(grid);
        dialogStage.setScene(scene);
        dialogStage.showAndWait();
    }

    private void showEntryForm(String title) {
        Stage dialogStage = new Stage();
        dialogStage.initModality(Modality.APPLICATION_MODAL);
        dialogStage.setTitle(title);

        GridPane grid = new GridPane();
        grid.setPadding(new Insets(20));
        grid.setHgap(10);
        grid.setVgap(10);

        TextField idField = new TextField();
        TextField nameField = new TextField();
        TextField xField = new TextField();
        TextField yField = new TextField();
        TextField ageField = new TextField();
        ComboBox<Color> colorBox = new ComboBox<>();
        colorBox.getItems().setAll(Color.values());
        ComboBox<DragonType> typeBox = new ComboBox<>();
        typeBox.getItems().setAll(DragonType.values());
        ComboBox<DragonCharacter> characterBox = new ComboBox<>();
        characterBox.getItems().setAll(DragonCharacter.values());

        CheckBox hasCaveCheck = new CheckBox();
        TextField depthField = new TextField();
        TextField treasuresField = new TextField();

        depthField.disableProperty().bind(hasCaveCheck.selectedProperty().not());
        treasuresField.disableProperty().bind(hasCaveCheck.selectedProperty().not());

        grid.add(new Label("Key:"), 0, 0);
        grid.add(idField, 1, 0);
        grid.add(new Label("Name:"), 0, 1);
        grid.add(nameField, 1, 1);
        grid.add(new Label("Coordinate X:"), 0, 2);
        grid.add(xField, 1, 2);
        grid.add(new Label("Coordinate Y:"), 0, 3);
        grid.add(yField, 1, 3);
        grid.add(new Label("Age:"), 0, 4);
        grid.add(ageField, 1, 4);
        grid.add(new Label("Color:"), 0, 5);
        grid.add(colorBox, 1, 5);
        grid.add(new Label("Type:"), 0, 6);
        grid.add(typeBox, 1, 6);
        grid.add(new Label("Character:"), 0, 7);
        grid.add(characterBox, 1, 7);
        grid.add(new Label("Has Cave:"), 0, 8);
        grid.add(hasCaveCheck, 1, 8);
        grid.add(new Label("Cave Depth:"), 0, 9);
        grid.add(depthField, 1, 9);
        grid.add(new Label("Cave Treasures:"), 0, 10);
        grid.add(treasuresField, 1, 10);


        colorBox.getSelectionModel().selectFirst();
        typeBox.getSelectionModel().selectFirst();
        characterBox.getSelectionModel().selectFirst();

        Button okButton = new Button("OK");
        Button cancelButton = new Button("Cancel");

        okButton.setOnAction(e -> {
            if (validateAndCreateEntry(idField, nameField, xField, yField, ageField, colorBox, typeBox, characterBox, hasCaveCheck, depthField, treasuresField)) {
                dialogStage.close();
            }
        });

        cancelButton.setOnAction(e -> dialogStage.close());

        HBox buttonBox = new HBox(10, cancelButton, okButton);
        buttonBox.setAlignment(Pos.CENTER_RIGHT);
        grid.add(buttonBox, 1, 11);

        Scene scene = new Scene(grid);
        dialogStage.setScene(scene);
        dialogStage.showAndWait();
    }


    private boolean validateAndCreateDragon(TextField nameField, TextField xField, TextField yField, TextField ageField,
                                            ComboBox<Color> colorBox, ComboBox<DragonType> typeBox, ComboBox<DragonCharacter> characterBox,
                                            CheckBox hasCaveCheck, TextField depthField, TextField treasuresField) {
        try {
            String name = nameField.getText();
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalArgumentException("Name cannot be empty.");
            }

            double x = Double.parseDouble(xField.getText().trim());
            long y = Long.parseLong(yField.getText().trim());
            if (y > 984) {
                throw new IllegalArgumentException("Y coordinate cannot be greater than 984.");
            }
            Coordinates coordinates = new Coordinates(x, y);

            int age = Integer.parseInt(ageField.getText().trim());
            if (age <= 0) {
                throw new IllegalArgumentException("Age must be greater than 0.");
            }

            Color color = colorBox.getValue();
            if (color == null) throw new IllegalArgumentException("A color must be selected.");

            DragonType type = typeBox.getValue();
            if (type == null) throw new IllegalArgumentException("A type must be selected.");
            DragonCharacter character = characterBox.getValue();

            DragonCave cave = null;
            if (hasCaveCheck.isSelected()) {
                if (depthField.getText().trim().isEmpty() || treasuresField.getText().trim().isEmpty()) {
                    throw new IllegalArgumentException("If a cave exists, both depth and treasures must be specified.");
                }
                int depth = Integer.parseInt(depthField.getText().trim());
                double treasures = Double.parseDouble(treasuresField.getText().trim());
                if (treasures <= 0) {
                    throw new IllegalArgumentException("Number of treasures must be greater than 0.");
                }
                cave = new DragonCave(depth, treasures);
            }

            this.resultDragon = new Dragon(name, coordinates, age, color, type, character, cave);
            return true;

        } catch (NumberFormatException nfe) {
            showAlert("Invalid Input", "Please enter valid numbers for the numeric fields (X, Y, Age, Depth, Treasures).");
            return false;
        } catch (IllegalArgumentException iae) {
            showAlert("Invalid Input", iae.getMessage());
            return false;
        }
    }

    private boolean validateAndCreateEntry(TextField idField, TextField nameField, TextField xField, TextField yField, TextField ageField,
                                           ComboBox<Color> colorBox, ComboBox<DragonType> typeBox, ComboBox<DragonCharacter> characterBox,
                                           CheckBox hasCaveCheck, TextField depthField, TextField treasuresField) {
        try {
            String id = idField.getText();
            if (id == null || id.trim().isEmpty()) {
                throw new IllegalArgumentException("Id cannot be empty.");
            }

            String name = nameField.getText();
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalArgumentException("Name cannot be empty.");
            }

            double x = Double.parseDouble(xField.getText().trim());
            long y = Long.parseLong(yField.getText().trim());
            if (y > 984) {
                throw new IllegalArgumentException("Y coordinate cannot be greater than 984.");
            }
            Coordinates coordinates = new Coordinates(x, y);

            int age = Integer.parseInt(ageField.getText().trim());
            if (age <= 0) {
                throw new IllegalArgumentException("Age must be greater than 0.");
            }

            Color color = colorBox.getValue();
            if (color == null) throw new IllegalArgumentException("A color must be selected.");

            DragonType type = typeBox.getValue();
            if (type == null) throw new IllegalArgumentException("A type must be selected.");
            DragonCharacter character = characterBox.getValue();

            DragonCave cave = null;
            if (hasCaveCheck.isSelected()) {
                if (depthField.getText().trim().isEmpty() || treasuresField.getText().trim().isEmpty()) {
                    throw new IllegalArgumentException("If a cave exists, both depth and treasures must be specified.");
                }
                int depth = Integer.parseInt(depthField.getText().trim());
                double treasures = Double.parseDouble(treasuresField.getText().trim());
                if (treasures <= 0) {
                    throw new IllegalArgumentException("Number of treasures must be greater than 0.");
                }
                cave = new DragonCave(depth, treasures);
            }

            this.resultEntry = new DragonDisplayWrapper(id, new Dragon(name, coordinates, age, color, type, character, cave));
            return true;

        } catch (NumberFormatException nfe) {
            showAlert("Invalid Input", "Please enter valid numbers for the numeric fields (X, Y, Age, Depth, Treasures).");
            return false;
        } catch (IllegalArgumentException iae) {
            showAlert("Invalid Input", iae.getMessage());
            return false;
        }
    }

    private void showAlert(String title, String message) {
        Alert alert = new Alert(Alert.AlertType.ERROR);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
}// ./app/target/maven-status/maven-compiler-plugin/testCompile/default-testCompile/inputFiles.lst
// ./app/target/maven-status/maven-compiler-plugin/testCompile/default-testCompile/createdFiles.lst
// ./app/target/maven-status/maven-compiler-plugin/compile/default-compile/inputFiles.lst
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/Main.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/BasicCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/local/ExecuteScriptCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/local/ExitCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/local/HelpCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/ClearCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/CountLessThanCharacterCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/InfoCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/InsertCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/LoginCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/PrintAscendingCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/PrintFieldDescendingTypeCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/RegisterCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/RemoveGreaterCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/RemoveGreaterKeyCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/RemoveKeyCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/ReplaceIfLowerCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/ShowCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/commands/server/UpdateCommand.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/ConnectionInterruptedException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/CustomException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/InfiniteFileRecursion.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/NoSuchColorException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/NoSuchElementException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/NullArgsForbiddenException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/NullForbiddenException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/RangeExceededException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/exceptions/WrongRequestException.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/AppStarter.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/DragonTableView.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/managers/ActionsManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/managers/AuthManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/managers/CommandsManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/managers/LocaleManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/screens/DragonFormScreen.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/screens/InfoScreen.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/gui/screens/LoginScreen.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/managers/ClientManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/managers/CollectionManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/managers/CommandManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/managers/ConnectionManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/managers/DragonCreationManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/managers/FileManager.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/utils/InputChecker.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/utils/InputTools.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/utils/RequestConstructor.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/utils/RequestResponseTool.java
/home/zhabka/git/ITMO/ITMO/labs/programming/lab8/app/src/main/java/utils/TypeComparator.java
// ./app/target/maven-status/maven-compiler-plugin/compile/default-compile/createdFiles.lst
managers/DragonCreationManager.class
commands/server/PrintAscendingCommand.class
commands/server/ShowCommand.class
gui/screens/LoginScreen.class
exceptions/NullForbiddenException.class
exceptions/ConnectionInterruptedException.class
commands/server/InsertCommand.class
commands/local/ExecuteScriptCommand.class
exceptions/NoSuchElementException.class
gui/DragonTableView$4.class
utils/RequestResponseTool.class
commands/server/ClearCommand.class
commands/server/CountLessThanCharacterCommand.class
commands/server/UpdateCommand.class
gui/screens/InfoScreen.class
utils/RequestConstructor.class
managers/FileManager$1.class
commands/local/HelpCommand.class
exceptions/WrongRequestException.class
gui/managers/ActionsManager.class
managers/ClientManager.class
commands/server/PrintFieldDescendingTypeCommand.class
gui/DragonTableView.class
commands/local/ExitCommand.class
utils/TypeComparator.class
commands/server/InfoCommand.class
gui/DragonTableView$3.class
exceptions/RangeExceededException.class
managers/CollectionManager.class
gui/screens/DragonFormScreen.class
gui/managers/CommandsManager.class
gui/DragonTableView$5.class
commands/BasicCommand.class
gui/AppStarter.class
commands/server/LoginCommand.class
commands/server/RegisterCommand.class
Main.class
commands/server/ReplaceIfLowerCommand.class
exceptions/InfiniteFileRecursion.class
gui/DragonTableView$2.class
managers/FileManager.class
gui/managers/LocaleManager.class
commands/server/RemoveGreaterCommand.class
gui/managers/AuthManager.class
commands/server/RemoveKeyCommand.class
utils/InputTools.class
exceptions/CustomException.class
commands/server/RemoveGreaterKeyCommand.class
gui/DragonTableView$1.class
managers/CommandManager.class
managers/ConnectionManager.class
exceptions/NoSuchColorException.class
utils/InputChecker.class
exceptions/NullArgsForbiddenException.class
// ./app/target/maven-archiver/pom.properties
artifactId=app
groupId=org.ITMO.s435169
version=v1
// ./app/pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.ITMO.s435169</groupId>
        <artifactId>lab_8</artifactId>
        <version>v1</version>
    </parent>

    <artifactId>app</artifactId>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.ITMO.s435169</groupId>
            <artifactId>common</artifactId>
            <version>v1</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-controls</artifactId>
            <version>22.0.1</version>
        </dependency>
        <dependency>
            <groupId>org.openjfx</groupId>
            <artifactId>javafx-fxml</artifactId>
            <version>17.0.2</version>
        </dependency>
    </dependencies>
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
            </resource>
        </resources>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>3.4.2</version>
                <configuration>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                    <archive>
                        <manifest>
                            <mainClass>Main</mainClass>
                        </manifest>
                    </archive>
                </configuration>
                <executions>
                    <execution>
                        <id>make-assembly</id>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.openjfx</groupId>
                <artifactId>javafx-maven-plugin</artifactId>
                <version>0.0.6</version>
            </plugin>
        </plugins>
    </build>
</project>// ./pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns="http://maven.apache.org/POM/4.0.0"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>org.ITMO.s435169</groupId>
    <artifactId>lab_8</artifactId>
    <version>v1</version>
    <packaging>pom</packaging>

    <modules>
        <module>app</module>
        <module>server</module>
        <module>common</module>
    </modules>
    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <jackson.version>2.18.2</jackson.version>
    </properties>


    <dependencies>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-jsr310 -->
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
            <version>2.18.2</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.postgresql/postgresql -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <version>42.7.5</version>
        </dependency>
    </dependencies>
</project>// ./script.sh
#!/bin/sh
echo
for file in `find . -type f | grep -v .idea | grep -v build | grep -v bin | grep -v 'gradle' | grep -v git | grep -v DS | grep -v .log | grep -v .class | grep -v .jar`
do
 echo "// ${file}"
 cat $file
done
